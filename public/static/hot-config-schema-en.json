{
    "components": {
        "schemas": {
            "cluster.log": {
                "properties": {
                    "console_handler": {
                        "description": "Log handler that prints log events to the EMQX console.",
                        "label": "Console Handler",
                        "$ref": "#/components/schemas/cluster.console_handler"
                    },
                    "file_handlers": {
                        "description": "File-based log handlers.",
                        "label": "File Handler",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/cluster.log_file_handler"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "broker.listener_wss_opts": {
                "properties": {
                    "cacertfile": {
                        "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
                        "label": "CACertfile",
                        "type": "string"
                    },
                    "certfile": {
                        "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
                        "label": "Certfile",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "</br>PEM format private key file.</br>",
                        "label": "Keyfile",
                        "type": "string"
                    },
                    "verify": {
                        "default": "verify_none",
                        "description": "</br>Enable or disable peer verification.</br>",
                        "label": "Verify peer",
                        "symbols": [
                            "verify_peer",
                            "verify_none"
                        ],
                        "type": "enum"
                    },
                    "reuse_sessions": {
                        "default": true,
                        "description": "</br>Enable TLS session reuse.</br>",
                        "label": "TLS session reuse",
                        "type": "boolean"
                    },
                    "depth": {
                        "default": 10,
                        "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
                        "label": "CACert Depth",
                        "type": "number"
                    },
                    "password": {
                        "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
                        "example": "",
                        "label": "Keyfile passphrase",
                        "type": "string"
                    },
                    "versions": {
                        "default": [
                            "tlsv1.3",
                            "tlsv1.2",
                            "tlsv1.1",
                            "tlsv1"
                        ],
                        "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "SSL versions",
                        "type": "array"
                    },
                    "ciphers": {
                        "default": [
                            "TLS_AES_256_GCM_SHA384",
                            "TLS_AES_128_GCM_SHA256",
                            "TLS_CHACHA20_POLY1305_SHA256",
                            "TLS_AES_128_CCM_SHA256",
                            "TLS_AES_128_CCM_8_SHA256",
                            "ECDHE-ECDSA-AES256-GCM-SHA384",
                            "ECDHE-RSA-AES256-GCM-SHA384",
                            "ECDHE-ECDSA-AES256-SHA384",
                            "ECDHE-RSA-AES256-SHA384",
                            "ECDH-ECDSA-AES256-GCM-SHA384",
                            "ECDH-RSA-AES256-GCM-SHA384",
                            "ECDH-ECDSA-AES256-SHA384",
                            "ECDH-RSA-AES256-SHA384",
                            "DHE-DSS-AES256-GCM-SHA384",
                            "DHE-DSS-AES256-SHA256",
                            "AES256-GCM-SHA384",
                            "AES256-SHA256",
                            "ECDHE-ECDSA-AES128-GCM-SHA256",
                            "ECDHE-RSA-AES128-GCM-SHA256",
                            "ECDHE-ECDSA-AES128-SHA256",
                            "ECDHE-RSA-AES128-SHA256",
                            "ECDH-ECDSA-AES128-GCM-SHA256",
                            "ECDH-RSA-AES128-GCM-SHA256",
                            "ECDH-ECDSA-AES128-SHA256",
                            "ECDH-RSA-AES128-SHA256",
                            "DHE-DSS-AES128-GCM-SHA256",
                            "DHE-DSS-AES128-SHA256",
                            "AES128-GCM-SHA256",
                            "AES128-SHA256",
                            "ECDHE-ECDSA-AES256-SHA",
                            "ECDHE-RSA-AES256-SHA",
                            "DHE-DSS-AES256-SHA",
                            "ECDH-ECDSA-AES256-SHA",
                            "ECDH-RSA-AES256-SHA",
                            "ECDHE-ECDSA-AES128-SHA",
                            "ECDHE-RSA-AES128-SHA",
                            "DHE-DSS-AES128-SHA",
                            "ECDH-ECDSA-AES128-SHA",
                            "ECDH-RSA-AES128-SHA",
                            "RSA-PSK-AES256-GCM-SHA384",
                            "RSA-PSK-AES256-CBC-SHA384",
                            "RSA-PSK-AES128-GCM-SHA256",
                            "RSA-PSK-AES128-CBC-SHA256",
                            "RSA-PSK-AES256-CBC-SHA",
                            "RSA-PSK-AES128-CBC-SHA"
                        ],
                        "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "",
                        "type": "array"
                    },
                    "user_lookup_fun": {
                        "default": "emqx_tls_psk:lookup",
                        "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
                        "label": "SSL PSK user lookup fun",
                        "type": "string"
                    },
                    "secure_renegotiate": {
                        "default": true,
                        "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
                        "label": "SSL renegotiate",
                        "type": "boolean"
                    },
                    "dhfile": {
                        "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
                        "label": "SSL dhfile",
                        "type": "string"
                    },
                    "fail_if_no_peer_cert": {
                        "default": false,
                        "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
                        "label": "SSL fail if no peer cert",
                        "type": "boolean"
                    },
                    "honor_cipher_order": {
                        "default": true,
                        "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
                        "label": "SSL honor cipher order",
                        "type": "boolean"
                    },
                    "client_renegotiation": {
                        "default": true,
                        "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
                        "label": "SSL client renegotiation",
                        "type": "boolean"
                    },
                    "handshake_timeout": {
                        "default": "15s",
                        "description": "</br>Maximum time duration allowed for the handshake to complete</br>",
                        "label": "Handshake timeout",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "broker.sysmon_os": {
                "properties": {
                    "cpu_check_interval": {
                        "default": "60s",
                        "description": "The time interval for the periodic CPU check.",
                        "label": "The time interval for the periodic CPU check.",
                        "type": "duration"
                    },
                    "cpu_high_watermark": {
                        "default": "80%",
                        "description": "The threshold, as percentage of system CPU load,</br> for how much system cpu can be used before the corresponding alarm is raised.",
                        "label": "CPU high watermark",
                        "type": "percent"
                    },
                    "cpu_low_watermark": {
                        "default": "60%",
                        "description": "The threshold, as percentage of system CPU load,</br> for how much system cpu can be used before the corresponding alarm is cleared.",
                        "label": "CPU low watermark",
                        "type": "percent"
                    },
                    "mem_check_interval": {
                        "default": "60s",
                        "description": "The time interval for the periodic memory check.",
                        "label": "Mem check interval",
                        "oneOf": [
                            {
                                "type": "duration"
                            },
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "sysmem_high_watermark": {
                        "default": "70%",
                        "description": "The threshold, as percentage of system memory,</br> for how much system memory can be allocated before the corresponding alarm is raised.",
                        "label": "SysMem high wartermark",
                        "type": "percent"
                    },
                    "procmem_high_watermark": {
                        "default": "5%",
                        "description": "The threshold, as percentage of system memory,</br> for how much system memory can be allocated by one Erlang process before</br> the corresponding alarm is raised.",
                        "label": "ProcMem high wartermark",
                        "type": "percent"
                    }
                },
                "type": "object"
            },
            "broker.sysmon": {
                "properties": {
                    "vm": {
                        "description": "vm Description",
                        "label": "vm",
                        "$ref": "#/components/schemas/broker.sysmon_vm"
                    },
                    "os": {
                        "description": "os Description",
                        "label": "os",
                        "$ref": "#/components/schemas/broker.sysmon_os"
                    },
                    "top": {
                        "description": "top Description",
                        "label": "top",
                        "$ref": "#/components/schemas/broker.sysmon_top"
                    }
                },
                "type": "object"
            },
            "dashboard.http": {
                "required": [
                    "bind",
                    "enable"
                ],
                "properties": {
                    "enable": {
                        "default": true,
                        "description": "Ignore or enable this listener",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "bind": {
                        "default": 18083,
                        "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
                        "example": "0.0.0.0:18083",
                        "label": "Bind",
                        "oneOf": [
                            {
                                "type": "ip_port"
                            },
                            {
                                "minimum": 1,
                                "type": "number"
                            }
                        ]
                    },
                    "num_acceptors": {
                        "default": 4,
                        "description": "Socket acceptor pool size for TCP protocols.",
                        "label": "Number of acceptors",
                        "type": "number"
                    },
                    "max_connections": {
                        "default": 512,
                        "description": "Maximum number of simultaneous connections.",
                        "label": "Maximum connections",
                        "type": "number"
                    },
                    "backlog": {
                        "default": 1024,
                        "description": "Defines the maximum length that the queue of pending connections can grow to.",
                        "label": "Backlog",
                        "type": "number"
                    },
                    "send_timeout": {
                        "default": "5s",
                        "description": "Send timeout for the socket.",
                        "label": "Send timeout",
                        "type": "duration"
                    },
                    "inet6": {
                        "default": false,
                        "description": "Enable IPv6 support, default is false, which means IPv4 only.",
                        "label": "IPv6",
                        "type": "boolean"
                    },
                    "ipv6_v6only": {
                        "default": false,
                        "description": "Disable IPv4-to-IPv6 mapping for the listener.",
                        "label": "IPv6 only",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-mysql.authentication": {
                "required": [
                    "database",
                    "server",
                    "query",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "mysql"
                        ],
                        "type": "enum"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "query": {
                        "description": "SQL used to query data for authentication, such as password hash.",
                        "label": "Query",
                        "type": "string"
                    },
                    "query_timeout": {
                        "default": "5s",
                        "description": "Timeout for the SQL query.",
                        "label": "Query Timeout",
                        "type": "duration"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "server": {
                        "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MySQL default port 3306 is used if `[:Port]` is not specified.</br>",
                        "label": "Server Host",
                        "type": "ip_port"
                    },
                    "database": {
                        "description": "Database name.",
                        "label": "Database Name",
                        "type": "string"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "username": {
                        "description": "EMQX's username in the external database.",
                        "label": "Username",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "auto_reconnect": {
                        "default": true,
                        "description": "Enable automatic reconnect to the database.",
                        "label": "Auto Reconnect Database",
                        "type": "boolean"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_static": {
                "properties": {
                    "seeds": {
                        "default": "",
                        "description": "List EMQX node names in the static cluster. See <code>node.name</code>.",
                        "items": {
                            "type": "string"
                        },
                        "label": "Cluster Static Seeds",
                        "readOnly": true,
                        "type": "array"
                    }
                },
                "type": "object"
            },
            "broker.shared_subscription_group": {
                "properties": {
                    "strategy": {
                        "default": "random",
                        "description": "Dispatch strategy for shared subscription.</br>- `random`: dispatch the message to a random selected subscriber</br>- `round_robin`: select the subscribers in a round-robin manner</br>- `sticky`: always use the last selected subscriber to dispatch,</br>until the subscriber disconnects.</br>- `hash`: select the subscribers by the hash of `clientIds`</br>- `local`: send to a random local subscriber. If local</br>subscriber was not found, send to a random subscriber cluster-wide</br>",
                        "label": "strategy",
                        "symbols": [
                            "random",
                            "round_robin",
                            "sticky",
                            "local",
                            "hash_topic",
                            "hash_clientid"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "cluster.console_handler": {
                "properties": {
                    "enable": {
                        "default": false,
                        "description": "Enable this log handler.",
                        "label": "Enable Log Handler",
                        "type": "boolean"
                    },
                    "level": {
                        "default": "warning",
                        "description": "</br>The log level for the current log handler.</br>Defaults to warning.</br>",
                        "label": "Log Level",
                        "symbols": [
                            "debug",
                            "info",
                            "notice",
                            "warning",
                            "error",
                            "critical",
                            "alert",
                            "emergency",
                            "all"
                        ],
                        "type": "enum"
                    },
                    "time_offset": {
                        "default": "system",
                        "description": "</br>The time offset to be used when formatting the timestamp.</br>Can be one of:</br>  - <code>system</code>: the time offset used by the local system</br>  - <code>utc</code>: the UTC time offset</br>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"</br>Defaults to: <code>system</code>.</br>",
                        "label": "Time Offset",
                        "type": "string"
                    },
                    "chars_limit": {
                        "default": "unlimited",
                        "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.",
                        "label": "Single Log Max Length",
                        "oneOf": [
                            {
                                "minimum": 100,
                                "type": "number"
                            },
                            {
                                "symbols": [
                                    "unlimited"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "formatter": {
                        "default": "text",
                        "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
                        "label": "Log Formatter",
                        "symbols": [
                            "text",
                            "json"
                        ],
                        "type": "enum"
                    },
                    "single_line": {
                        "default": true,
                        "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
                        "label": "Single Line Mode",
                        "type": "boolean"
                    },
                    "sync_mode_qlen": {
                        "default": 100,
                        "description": "As long as the number of buffered log events is lower than this value,</br>all log events are handled asynchronously. This means that the client process sending the log event,</br>by calling a log function in the Logger API, does not wait for a response from the handler</br>but continues executing immediately after the event is sent.</br>It is not affected by the time it takes the handler to print the event to the log device.</br>If the message queue grows larger than this value,</br>the handler starts handling log events synchronously instead,</br>meaning that the client process sending the event must wait for a response.</br>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,</br>asynchronous operation is resumed.</br>",
                        "label": "Queue Length before Entering Sync Mode",
                        "minimum": 1,
                        "type": "number"
                    },
                    "drop_mode_qlen": {
                        "default": 3000,
                        "description": "When the number of buffered log events is larger than this value, the new log events are dropped.</br>When drop mode is activated or deactivated, a message is printed in the logs.",
                        "label": "Queue Length before Entering Drop Mode",
                        "type": "string"
                    },
                    "flush_qlen": {
                        "default": 8000,
                        "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.</br>To flush events, the handler discards the buffered log messages without logging.",
                        "label": "Flush Threshold",
                        "type": "string"
                    },
                    "overload_kill": {
                        "description": "overload_kill Description",
                        "label": "overload_kill",
                        "$ref": "#/components/schemas/cluster.log_overload_kill"
                    },
                    "burst_limit": {
                        "description": "burst_limit Description",
                        "label": "burst_limit",
                        "$ref": "#/components/schemas/cluster.log_burst_limit"
                    },
                    "supervisor_reports": {
                        "default": "error",
                        "description": "</br>Type of supervisor reports that are logged. Defaults to <code>error</code></br>  - <code>error</code>: only log errors in the Erlang processes.</br>  - <code>progress</code>: log process startup.</br>",
                        "label": "Report Type",
                        "symbols": [
                            "error",
                            "progress"
                        ],
                        "type": "enum"
                    },
                    "max_depth": {
                        "default": 100,
                        "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
                        "label": "Max Depth",
                        "oneOf": [
                            {
                                "minimum": 1,
                                "type": "number"
                            },
                            {
                                "symbols": [
                                    "unlimited"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "type": "object"
            },
            "connector-http.request": {
                "properties": {
                    "method": {
                        "description": "HTTP method.",
                        "label": "HTTP Method",
                        "symbols": [
                            "post",
                            "put",
                            "get",
                            "delete"
                        ],
                        "type": "enum"
                    },
                    "path": {
                        "description": "URL path.",
                        "label": "URL Path",
                        "type": "string"
                    },
                    "body": {
                        "description": "HTTP request body.",
                        "label": "HTTP Body",
                        "type": "string"
                    },
                    "headers": {
                        "description": "List of HTTP headers.",
                        "label": "HTTP Headers",
                        "type": "string"
                    },
                    "request_timeout": {
                        "description": "HTTP request timeout.",
                        "label": "Request Timeout",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "broker.mqtt_ssl_listener": {
                "required": [
                    "bind"
                ],
                "properties": {
                    "bind": {
                        "default": 8883,
                        "description": "</br>IP address and port for the listening socket.</br>",
                        "label": "IP address and port",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "type": "ip_port"
                            }
                        ]
                    },
                    "acceptors": {
                        "default": 16,
                        "description": "</br>The size of the listener's receiving pool.</br>",
                        "label": "Acceptors Num",
                        "type": "string"
                    },
                    "max_connections": {
                        "default": "infinity",
                        "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
                        "label": "Max connections",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "mountpoint": {
                        "default": "",
                        "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
                        "label": "mountpoint",
                        "type": "string"
                    },
                    "zone": {
                        "default": "default",
                        "description": "</br>The configuration zone to which the listener belongs.</br>",
                        "label": "Zone",
                        "type": "string"
                    },
                    "limiter": {
                        "default": {},
                        "description": "</br>Type of the rate limit.</br>",
                        "label": "Type of the rate limit.",
                        "properties": {
                            "$ratelimit_name": {
                                "type": "string"
                            }
                        },
                        "type": "object"
                    },
                    "access_rules": {
                        "default": [
                            "allow all"
                        ],
                        "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Access rules",
                        "type": "array"
                    },
                    "proxy_protocol": {
                        "default": false,
                        "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
                        "label": "Proxy protocol",
                        "type": "boolean"
                    },
                    "proxy_protocol_timeout": {
                        "default": "3s",
                        "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
                        "label": "Proxy protocol timeout",
                        "type": "duration"
                    },
                    "authentication": {
                        "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
                        "items": {
                            "oneOf": [
                                {
                                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.jwks"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.public-key"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.post"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.get"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.sentinel"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mysql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                                }
                            ]
                        },
                        "label": "Per-listener authentication override",
                        "type": "array"
                    },
                    "tcp_options": {
                        "description": "tcp_options Description",
                        "label": "tcp_options",
                        "$ref": "#/components/schemas/broker.tcp_opts"
                    },
                    "ssl_options": {
                        "description": "ssl_options Description",
                        "label": "ssl_options",
                        "$ref": "#/components/schemas/broker.listener_ssl_opts"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_mcast": {
                "properties": {
                    "addr": {
                        "default": "239.192.0.1",
                        "description": "Multicast IPv4 address.",
                        "label": "Cluster Multicast Address",
                        "readOnly": true,
                        "type": "string"
                    },
                    "ports": {
                        "default": [
                            4369,
                            4370
                        ],
                        "description": "List of UDP ports used for service discovery.</br>Note: probe messages are broadcast to all the specified ports.</br>          ",
                        "items": {
                            "type": "number"
                        },
                        "label": "Cluster Multicast Ports",
                        "readOnly": true,
                        "type": "array"
                    },
                    "iface": {
                        "default": "0.0.0.0",
                        "description": "Local IP address the node discovery service needs to bind to.",
                        "label": "Cluster Multicast Interface",
                        "readOnly": true,
                        "type": "string"
                    },
                    "ttl": {
                        "default": 255,
                        "description": "Time-to-live (TTL) for the outgoing UDP datagrams.",
                        "label": "Cluster Multicast TTL",
                        "maximum": 255,
                        "minimum": 0,
                        "readOnly": true,
                        "type": "number"
                    },
                    "loop": {
                        "default": true,
                        "description": "If <code>true</code>, loop UDP datagrams back to the local socket.",
                        "label": "Cluster Multicast Loop",
                        "readOnly": true,
                        "type": "boolean"
                    },
                    "sndbuf": {
                        "default": "16KB",
                        "description": "Size of the kernel-level buffer for outgoing datagrams.",
                        "label": "Cluster Muticast Sendbuf",
                        "readOnly": true,
                        "type": "byteSize"
                    },
                    "recbuf": {
                        "default": "16KB",
                        "description": "Size of the kernel-level buffer for incoming datagrams.",
                        "label": "Cluster Muticast Sendbuf",
                        "readOnly": true,
                        "type": "byteSize"
                    },
                    "buffer": {
                        "default": "32KB",
                        "description": "Size of the user-level buffer.",
                        "label": "Cluster Muticast Buffer",
                        "readOnly": true,
                        "type": "byteSize"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_k8s": {
                "properties": {
                    "apiserver": {
                        "default": "http://10.110.111.204:8080",
                        "description": "Kubernetes API endpoint URL.",
                        "label": "Cluster k8s ApiServer",
                        "readOnly": true,
                        "type": "string"
                    },
                    "service_name": {
                        "default": "emqx",
                        "description": "EMQX broker service name.",
                        "label": "K8s Service Name",
                        "readOnly": true,
                        "type": "string"
                    },
                    "address_type": {
                        "default": "ip",
                        "description": "Address type used for connecting to the discovered nodes.",
                        "label": "K8s Address Type",
                        "readOnly": true,
                        "symbols": [
                            "ip",
                            "dns",
                            "hostname"
                        ],
                        "type": "enum"
                    },
                    "app_name": {
                        "default": "emqx",
                        "description": "This parameter should be set to the part of the <code>node.name</code></br>before the '@'.</br>For example, if the <code>node.name</code> is <code>emqx@127.0.0.1</code>, then this parameter</br>should be set to <code>emqx</code>.",
                        "label": "K8s App Name",
                        "readOnly": true,
                        "type": "string"
                    },
                    "namespace": {
                        "default": "default",
                        "description": "Kubernetes namespace.",
                        "label": "K8s Namespace",
                        "readOnly": true,
                        "type": "string"
                    },
                    "suffix": {
                        "default": "pod.local",
                        "description": "Node name suffix.</br>Note: this parameter is only relevant when <code>address_type</code> is <code>dns</code></br>or <code>hostname</code>.",
                        "label": "K8s Suffix",
                        "readOnly": true,
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "broker.deflate_opts": {
                "properties": {
                    "level": {
                        "description": "</br>Compression level.</br>",
                        "label": "Compression level",
                        "symbols": [
                            "none",
                            "default",
                            "best_compression",
                            "best_speed"
                        ],
                        "type": "enum"
                    },
                    "mem_level": {
                        "default": 8,
                        "description": "</br>Specifies the size of the compression state.</br>Lower values decrease memory usage per connection.</br>",
                        "label": "Size of the compression state",
                        "maximum": 9,
                        "minimum": 1,
                        "type": "number"
                    },
                    "strategy": {
                        "default": "default",
                        "description": "</br>Specifies the compression strategy.</br>",
                        "label": "compression strategy",
                        "symbols": [
                            "default",
                            "filtered",
                            "huffman_only",
                            "rle"
                        ],
                        "type": "enum"
                    },
                    "server_context_takeover": {
                        "default": "takeover",
                        "description": "</br>Takeover means the compression state is retained between server messages.</br>",
                        "label": "Server context takeover",
                        "symbols": [
                            "takeover",
                            "no_takeover"
                        ],
                        "type": "enum"
                    },
                    "client_context_takeover": {
                        "default": "takeover",
                        "description": "</br>Takeover means the compression state is retained between client messages.</br>",
                        "label": "Client context takeover",
                        "symbols": [
                            "takeover",
                            "no_takeover"
                        ],
                        "type": "enum"
                    },
                    "server_max_window_bits": {
                        "default": 15,
                        "description": "</br>Specifies the size of the compression context for the server.</br>",
                        "label": "Server compression max window size",
                        "maximum": 15,
                        "minimum": 8,
                        "type": "number"
                    },
                    "client_max_window_bits": {
                        "default": 15,
                        "description": "</br>Specifies the size of the compression context for the client.</br>",
                        "label": "Client compression max window size",
                        "maximum": 15,
                        "minimum": 8,
                        "type": "number"
                    }
                },
                "type": "object"
            },
            "broker.tcp_opts": {
                "properties": {
                    "active_n": {
                        "default": 100,
                        "description": "</br>Specify the {active, N} option for this Socket.</br>See: https://erlang.org/doc/man/inet.html#setopts-2</br>",
                        "label": "active_n",
                        "type": "number"
                    },
                    "backlog": {
                        "default": 1024,
                        "description": "</br>TCP backlog defines the maximum length that the queue of</br> pending connections can grow to.</br>",
                        "label": "TCP backlog length",
                        "type": "number"
                    },
                    "send_timeout": {
                        "default": "15s",
                        "description": "</br>The TCP send timeout for the connections.</br>",
                        "label": "TCP send timeout",
                        "type": "duration"
                    },
                    "send_timeout_close": {
                        "default": true,
                        "description": "</br>Close the connection if send timeout.</br>",
                        "label": "TCP send timeout close",
                        "type": "boolean"
                    },
                    "recbuf": {
                        "description": "</br>The TCP receive buffer (OS kernel) for the connections.</br>",
                        "example": "2KB",
                        "label": "TCP receive buffer",
                        "type": "byteSize"
                    },
                    "sndbuf": {
                        "description": "</br>The TCP send buffer (OS kernel) for the connections.</br>",
                        "example": "4KB",
                        "label": "TCP send buffer",
                        "type": "byteSize"
                    },
                    "buffer": {
                        "description": "</br>The size of the user-space buffer used by the driver.</br>",
                        "example": "4KB",
                        "label": "TCP user-space buffer",
                        "type": "byteSize"
                    },
                    "high_watermark": {
                        "default": "1MB",
                        "description": "</br>The socket is set to a busy state when the amount of data queued internally</br>  by the VM socket implementation reaches this limit.</br>",
                        "label": "TCP 高水位线",
                        "type": "byteSize"
                    },
                    "nodelay": {
                        "default": false,
                        "description": "</br>The TCP_NODELAY flag for the connections.</br>",
                        "label": "TCP_NODELAY",
                        "type": "boolean"
                    },
                    "reuseaddr": {
                        "default": true,
                        "description": "</br>The SO_REUSEADDR flag for the connections.</br>",
                        "label": "SO_REUSEADDR",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "cluster.log_file_handler": {
                "properties": {
                    "file": {
                        "description": "Name the log file.",
                        "label": "Log File Name",
                        "type": "string"
                    },
                    "rotation": {
                        "description": "rotation Description",
                        "label": "rotation",
                        "$ref": "#/components/schemas/cluster.log_rotation"
                    },
                    "max_size": {
                        "default": "50MB",
                        "description": "This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes.",
                        "label": "Rotation Size",
                        "oneOf": [
                            {
                                "type": "byteSize"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Enable this log handler.",
                        "label": "Enable Log Handler",
                        "type": "boolean"
                    },
                    "level": {
                        "default": "warning",
                        "description": "</br>The log level for the current log handler.</br>Defaults to warning.</br>",
                        "label": "Log Level",
                        "symbols": [
                            "debug",
                            "info",
                            "notice",
                            "warning",
                            "error",
                            "critical",
                            "alert",
                            "emergency",
                            "all"
                        ],
                        "type": "enum"
                    },
                    "time_offset": {
                        "default": "system",
                        "description": "</br>The time offset to be used when formatting the timestamp.</br>Can be one of:</br>  - <code>system</code>: the time offset used by the local system</br>  - <code>utc</code>: the UTC time offset</br>  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"</br>Defaults to: <code>system</code>.</br>",
                        "label": "Time Offset",
                        "type": "string"
                    },
                    "chars_limit": {
                        "default": "unlimited",
                        "description": "Set the maximum length of a single log message. If this length is exceeded, the log message will be truncated.",
                        "label": "Single Log Max Length",
                        "oneOf": [
                            {
                                "minimum": 100,
                                "type": "number"
                            },
                            {
                                "symbols": [
                                    "unlimited"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "formatter": {
                        "default": "text",
                        "description": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
                        "label": "Log Formatter",
                        "symbols": [
                            "text",
                            "json"
                        ],
                        "type": "enum"
                    },
                    "single_line": {
                        "default": true,
                        "description": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
                        "label": "Single Line Mode",
                        "type": "boolean"
                    },
                    "sync_mode_qlen": {
                        "default": 100,
                        "description": "As long as the number of buffered log events is lower than this value,</br>all log events are handled asynchronously. This means that the client process sending the log event,</br>by calling a log function in the Logger API, does not wait for a response from the handler</br>but continues executing immediately after the event is sent.</br>It is not affected by the time it takes the handler to print the event to the log device.</br>If the message queue grows larger than this value,</br>the handler starts handling log events synchronously instead,</br>meaning that the client process sending the event must wait for a response.</br>When the handler reduces the message queue to a level below the sync_mode_qlen threshold,</br>asynchronous operation is resumed.</br>",
                        "label": "Queue Length before Entering Sync Mode",
                        "minimum": 1,
                        "type": "number"
                    },
                    "drop_mode_qlen": {
                        "default": 3000,
                        "description": "When the number of buffered log events is larger than this value, the new log events are dropped.</br>When drop mode is activated or deactivated, a message is printed in the logs.",
                        "label": "Queue Length before Entering Drop Mode",
                        "type": "string"
                    },
                    "flush_qlen": {
                        "default": 8000,
                        "description": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.</br>To flush events, the handler discards the buffered log messages without logging.",
                        "label": "Flush Threshold",
                        "type": "string"
                    },
                    "overload_kill": {
                        "description": "overload_kill Description",
                        "label": "overload_kill",
                        "$ref": "#/components/schemas/cluster.log_overload_kill"
                    },
                    "burst_limit": {
                        "description": "burst_limit Description",
                        "label": "burst_limit",
                        "$ref": "#/components/schemas/cluster.log_burst_limit"
                    },
                    "supervisor_reports": {
                        "default": "error",
                        "description": "</br>Type of supervisor reports that are logged. Defaults to <code>error</code></br>  - <code>error</code>: only log errors in the Erlang processes.</br>  - <code>progress</code>: log process startup.</br>",
                        "label": "Report Type",
                        "symbols": [
                            "error",
                            "progress"
                        ],
                        "type": "enum"
                    },
                    "max_depth": {
                        "default": 100,
                        "description": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
                        "label": "Max Depth",
                        "oneOf": [
                            {
                                "minimum": 1,
                                "type": "number"
                            },
                            {
                                "symbols": [
                                    "unlimited"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "type": "object"
            },
            "broker.mqtt_tcp_listener": {
                "required": [
                    "bind"
                ],
                "properties": {
                    "bind": {
                        "default": 1883,
                        "description": "</br>IP address and port for the listening socket.</br>",
                        "label": "IP address and port",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "type": "ip_port"
                            }
                        ]
                    },
                    "acceptors": {
                        "default": 16,
                        "description": "</br>The size of the listener's receiving pool.</br>",
                        "label": "Acceptors Num",
                        "type": "string"
                    },
                    "max_connections": {
                        "default": "infinity",
                        "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
                        "label": "Max connections",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "mountpoint": {
                        "default": "",
                        "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
                        "label": "mountpoint",
                        "type": "string"
                    },
                    "zone": {
                        "default": "default",
                        "description": "</br>The configuration zone to which the listener belongs.</br>",
                        "label": "Zone",
                        "type": "string"
                    },
                    "limiter": {
                        "default": {},
                        "description": "</br>Type of the rate limit.</br>",
                        "label": "Type of the rate limit.",
                        "properties": {
                            "$ratelimit_name": {
                                "type": "string"
                            }
                        },
                        "type": "object"
                    },
                    "access_rules": {
                        "default": [
                            "allow all"
                        ],
                        "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Access rules",
                        "type": "array"
                    },
                    "proxy_protocol": {
                        "default": false,
                        "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
                        "label": "Proxy protocol",
                        "type": "boolean"
                    },
                    "proxy_protocol_timeout": {
                        "default": "3s",
                        "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
                        "label": "Proxy protocol timeout",
                        "type": "duration"
                    },
                    "authentication": {
                        "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
                        "items": {
                            "oneOf": [
                                {
                                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.jwks"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.public-key"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.post"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.get"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.sentinel"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mysql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                                }
                            ]
                        },
                        "label": "Per-listener authentication override",
                        "type": "array"
                    },
                    "tcp_options": {
                        "description": "tcp_options Description",
                        "label": "tcp_options",
                        "$ref": "#/components/schemas/broker.tcp_opts"
                    }
                },
                "type": "object"
            },
            "broker.sysmon_top": {
                "properties": {
                    "num_items": {
                        "default": 10,
                        "description": "The number of top processes per monitoring group",
                        "label": "Top num items",
                        "minimum": 1,
                        "type": "number"
                    },
                    "sample_interval": {
                        "default": "2s",
                        "description": "Specifies how often process top should be collected",
                        "label": "Top sample interval",
                        "type": "duration"
                    },
                    "max_procs": {
                        "default": 1000000,
                        "description": "Stop collecting data when the number of processes</br>in the VM exceeds this value",
                        "label": "Max procs",
                        "minimum": 1,
                        "type": "number"
                    },
                    "db_hostname": {
                        "default": "",
                        "description": "Hostname of the PostgreSQL database that collects the data points",
                        "label": "DB Hostname",
                        "type": "string"
                    },
                    "db_port": {
                        "default": 5432,
                        "description": "Port of the PostgreSQL database that collects the data points",
                        "label": "DB Port",
                        "type": "number"
                    },
                    "db_username": {
                        "default": "system_monitor",
                        "description": "Username of the PostgreSQL database",
                        "label": "DB Username",
                        "type": "string"
                    },
                    "db_password": {
                        "default": "system_monitor_password",
                        "description": "EMQX user password in the PostgreSQL database",
                        "label": "DB Password",
                        "type": "string"
                    },
                    "db_name": {
                        "default": "postgres",
                        "description": "PostgreSQL database name",
                        "label": "DB Name",
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "authn-hash.bcrypt_rw": {
                "required": [
                    "name"
                ],
                "properties": {
                    "name": {
                        "description": "BCRYPT password hashing.",
                        "label": "name",
                        "symbols": [
                            "bcrypt"
                        ],
                        "type": "enum"
                    },
                    "salt_rounds": {
                        "default": 10,
                        "description": "Salt rounds for BCRYPT password generation.",
                        "example": 10,
                        "label": "salt_rounds",
                        "type": "number"
                    }
                },
                "type": "object"
            },
            "broker.listeners": {
                "properties": {
                    "tcp": {
                        "description": "</br>TCP listeners</br>",
                        "label": "TCP listeners",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.mqtt_tcp_listener"
                            }
                        },
                        "type": "object"
                    },
                    "ssl": {
                        "description": "</br>SSL listeners</br>",
                        "label": "SSL listeners",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.mqtt_ssl_listener"
                            }
                        },
                        "type": "object"
                    },
                    "ws": {
                        "description": "</br>HTTP websocket listeners</br>",
                        "label": "HTTP websocket listeners",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.mqtt_ws_listener"
                            }
                        },
                        "type": "object"
                    },
                    "wss": {
                        "description": "</br>HTTPS websocket listeners</br>",
                        "label": "HTTPS websocket listeners",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.mqtt_wss_listener"
                            }
                        },
                        "type": "object"
                    },
                    "quic": {
                        "description": "</br>QUIC listeners</br>",
                        "label": "QUIC listeners",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.mqtt_quic_listener"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "authn-http.post": {
                "required": [
                    "url",
                    "backend",
                    "mechanism",
                    "method"
                ],
                "properties": {
                    "method": {
                        "default": "post",
                        "description": "HTTP request method.",
                        "label": "Request Method",
                        "symbols": [
                            "post"
                        ],
                        "type": "enum"
                    },
                    "headers": {
                        "default": {
                            "accept": "application/json",
                            "cache-control": "no-cache",
                            "connection": "keep-alive",
                            "content-type": "application/json",
                            "keep-alive": "timeout=30, max=1000"
                        },
                        "description": "List of HTTP Headers.",
                        "label": "Headers",
                        "type": "string"
                    },
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "http"
                        ],
                        "type": "enum"
                    },
                    "url": {
                        "description": "URL of the HTTP server.",
                        "label": "URL",
                        "type": "string"
                    },
                    "body": {
                        "description": "HTTP request body.",
                        "label": "Request Body",
                        "type": "string"
                    },
                    "request_timeout": {
                        "default": "5s",
                        "description": "HTTP request timeout.",
                        "label": "Request Timeout",
                        "type": "duration"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "connect_timeout": {
                        "default": "15s",
                        "description": "The timeout when connecting to the HTTP server.",
                        "label": "Connect Timeout",
                        "type": "duration"
                    },
                    "enable_pipelining": {
                        "default": 100,
                        "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
                        "label": "HTTP Pipelineing",
                        "type": "string"
                    },
                    "max_retries": {
                        "default": 5,
                        "description": "Max retry times if error on sending request.",
                        "label": "Max Retries",
                        "minimum": 1,
                        "type": "number"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "The pool size.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "request": {
                        "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
                        "label": "Request",
                        "$ref": "#/components/schemas/connector-http.request"
                    },
                    "retry_interval": {
                        "default": "1s",
                        "description": "Interval between retries.",
                        "label": "Retry Interval",
                        "type": "duration"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "zone.force_gc": {
                "properties": {
                    "enable": {
                        "description": "Enable forced garbage collection.",
                        "label": "Enable forced garbage collection.",
                        "type": "boolean"
                    },
                    "count": {
                        "description": "GC the process after this many received messages.",
                        "label": "Process GC messages num",
                        "minimum": 0,
                        "type": "number"
                    },
                    "bytes": {
                        "description": "GC the process after specified number of bytes have passed through.",
                        "label": "Process GC bytes",
                        "type": "byteSize"
                    }
                },
                "type": "object"
            },
            "cluster.log_burst_limit": {
                "properties": {
                    "enable": {
                        "default": true,
                        "description": "Enable log burst control feature.",
                        "label": "Enable Burst",
                        "type": "boolean"
                    },
                    "max_count": {
                        "default": 10000,
                        "description": "Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`.",
                        "label": "Events Number",
                        "type": "string"
                    },
                    "window_time": {
                        "default": "1s",
                        "description": "See <code>max_count</code>.",
                        "label": "Window Time",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "cluster.node": {
                "required": [
                    "data_dir"
                ],
                "properties": {
                    "name": {
                        "default": "emqx@127.0.0.1",
                        "description": "Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or</br><code>%name%@IPv4</code> format.</br>          ",
                        "label": "Node Name",
                        "readOnly": true,
                        "type": "string"
                    },
                    "cookie": {
                        "default": "emqxsecretcookie",
                        "description": "Secret cookie is a random string that should be the same on all nodes in</br>the given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that</br>belong to different clusters from accidentally connecting to each other.",
                        "label": "Node Cookie",
                        "readOnly": true,
                        "type": "string"
                    },
                    "data_dir": {
                        "description": "</br>Path to the persistent data directory.</br>Possible auto-created subdirectories are:</br>- `mnesia/<node_name>`: EMQX's built-in database directory.</br>For example, `mnesia/emqx@127.0.0.1`.</br>There should be only one such subdirectory.</br>Meaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),</br>the old dir should be deleted first.</br>- `configs`: Generated configs at boot time, and cluster/local override configs.</br>- `patches`: Hot-patch beam files are to be placed here.</br>- `trace`: Trace log files.</br></br>**NOTE**: One data dir cannot be shared by two or more EMQX nodes.</br>",
                        "label": "Node Data Dir",
                        "readOnly": true,
                        "type": "string"
                    },
                    "config_files": {
                        "description": "List of configuration files that are read during startup. The order is</br>significant: later configuration files override the previous ones.</br>          ",
                        "items": {
                            "type": "string"
                        },
                        "label": "Config Files",
                        "readOnly": true,
                        "type": "array"
                    },
                    "global_gc_interval": {
                        "default": "15m",
                        "description": "Periodic garbage collection interval.",
                        "label": "Global GC Interval",
                        "readOnly": true,
                        "type": "duration"
                    },
                    "crash_dump_file": {
                        "default": "log/erl_crash.dump",
                        "description": "Location of the crash dump file.",
                        "label": "Crash Dump File",
                        "readOnly": true,
                        "type": "string"
                    },
                    "crash_dump_seconds": {
                        "default": "30s",
                        "description": "The number of seconds that the broker is allowed to spend writing a crash dump.",
                        "label": "Crash Dump Seconds",
                        "readOnly": true,
                        "type": "duration"
                    },
                    "crash_dump_bytes": {
                        "default": "100MB",
                        "description": "The maximum size of a crash dump file in bytes.",
                        "label": "Crash Dump Bytes",
                        "readOnly": true,
                        "type": "byteSize"
                    },
                    "dist_net_ticktime": {
                        "default": "2m",
                        "description": "This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected.",
                        "label": "Dist Net TickTime",
                        "readOnly": true,
                        "type": "duration"
                    },
                    "backtrace_depth": {
                        "default": 23,
                        "description": "Maximum depth of the call stack printed in error messages and</br><code>process_info</code>.</br>          ",
                        "label": "BackTrace Depth",
                        "readOnly": true,
                        "type": "number"
                    },
                    "applications": {
                        "default": "",
                        "description": "List of Erlang applications that shall be rebooted when the EMQX broker joins the cluster.</br>          ",
                        "label": "Application",
                        "readOnly": true,
                        "type": "comma_separated_string"
                    },
                    "etc_dir": {
                        "description": "<code>etc</code> dir for the node",
                        "label": "Etc Dir",
                        "readOnly": true,
                        "type": "string"
                    },
                    "cluster_call": {
                        "description": "cluster_call Description",
                        "label": "cluster_call",
                        "readOnly": true,
                        "$ref": "#/components/schemas/cluster.cluster_call"
                    },
                    "db_backend": {
                        "default": "rlog",
                        "description": "</br>Select the backend for the embedded database.</br><code>rlog</code> is the default backend,</br>that is suitable for very large clusters.</br><code>mnesia</code> is a backend that offers decent performance in small clusters.</br>",
                        "label": "DB Backend",
                        "readOnly": true,
                        "symbols": [
                            "mnesia",
                            "rlog"
                        ],
                        "type": "enum"
                    },
                    "db_role": {
                        "default": "core",
                        "description": "</br>Select a node role.</br><code>core</code> nodes provide durability of the data, and take care of writes.</br>It is recommended to place core nodes in different racks or different availability zones.</br><code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster</br>doesn't affect database redundancy</br>It is recommended to have more replicant nodes than core nodes.</br>Note: this parameter only takes effect when the <code>backend</code> is set</br>to <code>rlog</code>.</br>",
                        "label": "DB Role",
                        "readOnly": true,
                        "symbols": [
                            "core",
                            "replicant"
                        ],
                        "type": "enum"
                    },
                    "rpc_module": {
                        "default": "gen_rpc",
                        "description": "Protocol used for pushing transaction logs to the replicant nodes.",
                        "label": "RPC Module",
                        "readOnly": true,
                        "symbols": [
                            "gen_rpc",
                            "rpc"
                        ],
                        "type": "enum"
                    },
                    "tlog_push_mode": {
                        "default": "async",
                        "description": "</br>In sync mode the core node waits for an ack from the replicant nodes before sending the next</br>transaction log entry.</br>",
                        "label": "Tlog Push Mode",
                        "readOnly": true,
                        "symbols": [
                            "sync",
                            "async"
                        ],
                        "type": "enum"
                    },
                    "default_shard_transport": {
                        "default": "gen_rpc",
                        "description": "Defines the default transport for pushing transaction logs.</br>This may be overridden on a per-shard basis in <code>db.shard_transports</code>.</br><code>gen_rpc</code> uses the <code>gen_rpc</code> library,</br><code>distr</code> uses the Erlang distribution.</br>",
                        "label": "Default Shard Transport",
                        "symbols": [
                            "gen_rpc",
                            "distr"
                        ],
                        "type": "enum"
                    },
                    "shard_transports": {
                        "default": {},
                        "description": "Allows to tune the transport method used for transaction log replication, on a per-shard basis.</br><code>gen_rpc</code> uses the <code>gen_rpc</code> library,</br><code>distr</code> uses the Erlang distribution.</br>If not specified,</br>the default is to use the value set in <code>db.default_shard_transport</code>.",
                        "label": "Shard Transports",
                        "properties": {
                            "$shard": {
                                "symbols": [
                                    "gen_rpc",
                                    "distr"
                                ],
                                "type": "enum"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_dns": {
                "properties": {
                    "name": {
                        "default": "localhost",
                        "description": "The domain name of the EMQX cluster.",
                        "label": "Cluster Dns Name",
                        "readOnly": true,
                        "type": "string"
                    },
                    "app": {
                        "default": "emqx",
                        "description": "The symbolic name of the EMQX service.",
                        "label": "Cluster DNS App",
                        "readOnly": true,
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "emqx_connector_mongo.topology": {
                "properties": {
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "max_overflow": {
                        "default": 0,
                        "description": "Max Overflow.",
                        "label": "Max Overflow",
                        "minimum": 1,
                        "type": "number"
                    },
                    "overflow_ttl": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "overflow_check_period": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "local_threshold_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "connect_timeout_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "socket_timeout_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "server_selection_timeout_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "wait_queue_timeout_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "heartbeat_frequency_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    },
                    "min_heartbeat_frequency_ms": {
                        "description": "Time interval, such as timeout or TTL.",
                        "label": "Time Interval",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "authn-redis.cluster": {
                "required": [
                    "database",
                    "redis_type",
                    "servers",
                    "cmd",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "redis"
                        ],
                        "type": "enum"
                    },
                    "cmd": {
                        "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
                        "label": "Command",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "servers": {
                        "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Servers",
                        "type": "array"
                    },
                    "redis_type": {
                        "description": "Cluster mode",
                        "label": "Cluster Mode",
                        "symbols": [
                            "cluster"
                        ],
                        "type": "enum"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "database": {
                        "default": 0,
                        "description": "Redis database ID.",
                        "label": "Database ID",
                        "type": "number"
                    },
                    "auto_reconnect": {
                        "default": true,
                        "description": "Enable automatic reconnect to the database.",
                        "label": "Auto Reconnect Database",
                        "type": "boolean"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "authn-jwt.hmac-based": {
                "required": [
                    "mechanism",
                    "secret",
                    "algorithm",
                    "use_jwks"
                ],
                "properties": {
                    "use_jwks": {
                        "description": "Whether to use JWKS.",
                        "label": "Whether to Use JWKS",
                        "symbols": [
                            false
                        ],
                        "type": "enum"
                    },
                    "algorithm": {
                        "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
                        "label": "JWT Signing Algorithm",
                        "symbols": [
                            "hmac-based"
                        ],
                        "type": "enum"
                    },
                    "secret": {
                        "description": "The key to verify the JWT using HMAC algorithm.",
                        "label": "Secret",
                        "type": "string"
                    },
                    "secret_base64_encoded": {
                        "default": false,
                        "description": "Whether secret is base64 encoded.",
                        "label": "Whether Secret is Base64 Encoded",
                        "type": "boolean"
                    },
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "jwt"
                        ],
                        "type": "enum"
                    },
                    "acl_claim_name": {
                        "default": "acl",
                        "description": "JWT claim name to use for getting ACL rules.",
                        "label": "acl_claim_name",
                        "type": "string"
                    },
                    "verify_claims": {
                        "default": {},
                        "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Verify Claims",
                        "type": "array"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "zone.flapping_detect": {
                "properties": {
                    "enable": {
                        "description": "Enable flapping connection detection feature.",
                        "label": "Enable flapping detection",
                        "type": "boolean"
                    },
                    "max_count": {
                        "description": "The maximum number of disconnects allowed for a MQTT Client in `window_time`",
                        "label": "Max count",
                        "type": "number"
                    },
                    "window_time": {
                        "description": "The time window for flapping detection.",
                        "label": "Window time",
                        "type": "duration"
                    },
                    "ban_time": {
                        "description": "How long the flapping clientid will be banned.",
                        "label": "Ban time",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "zone.stats": {
                "properties": {
                    "enable": {
                        "description": "Enable/disable statistic data collection.",
                        "label": "Enable/disable statistic data collection.",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-mongodb.replica-set": {
                "required": [
                    "database",
                    "replica_set_name",
                    "servers",
                    "mongo_type",
                    "collection",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "mongodb"
                        ],
                        "type": "enum"
                    },
                    "collection": {
                        "description": "Collection used to store authentication data.",
                        "label": "Collection",
                        "type": "string"
                    },
                    "filter": {
                        "default": {},
                        "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
                        "label": "Filter",
                        "type": "string"
                    },
                    "password_hash_field": {
                        "default": "password_hash",
                        "description": "Document field that contains password hash.",
                        "label": "Password Hash Field",
                        "type": "string"
                    },
                    "salt_field": {
                        "default": "salt",
                        "description": "Document field that contains the password salt.",
                        "label": "Salt Field",
                        "type": "string"
                    },
                    "is_superuser_field": {
                        "default": "is_superuser",
                        "description": "Document field that defines if the user has superuser privileges.",
                        "label": "Is Superuser Field",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "mongo_type": {
                        "default": "rs",
                        "description": "Replica set.",
                        "label": "Replica set",
                        "symbols": [
                            "rs"
                        ],
                        "type": "enum"
                    },
                    "servers": {
                        "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Servers",
                        "type": "array"
                    },
                    "w_mode": {
                        "default": "unsafe",
                        "description": "Write mode.",
                        "label": "Write Mode",
                        "symbols": [
                            "unsafe",
                            "safe"
                        ],
                        "type": "enum"
                    },
                    "r_mode": {
                        "default": "master",
                        "description": "Read mode.",
                        "label": "Read Mode",
                        "symbols": [
                            "master",
                            "slave_ok"
                        ],
                        "type": "enum"
                    },
                    "replica_set_name": {
                        "description": "Name of the replica set.",
                        "label": "Replica Set Name",
                        "type": "string"
                    },
                    "srv_record": {
                        "default": false,
                        "description": "Use DNS SRV record.",
                        "label": "Srv Record",
                        "type": "boolean"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "username": {
                        "description": "EMQX's username in the external database.",
                        "label": "Username",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "auth_source": {
                        "description": "Database name associated with the user's credentials.",
                        "label": "Auth Source",
                        "type": "string"
                    },
                    "database": {
                        "description": "Database name.",
                        "label": "Database Name",
                        "type": "string"
                    },
                    "topology": {
                        "description": "topology Description",
                        "label": "topology",
                        "$ref": "#/components/schemas/emqx_connector_mongo.topology"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "broker.zone": {
                "properties": {
                    "mqtt": {
                        "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                        "label": "mqtt",
                        "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "stats": {
                        "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                        "label": "stats",
                        "$ref": "#/components/schemas/zone.stats"
                    },
                    "flapping_detect": {
                        "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                        "label": "flapping_detect",
                        "$ref": "#/components/schemas/zone.flapping_detect"
                    },
                    "force_shutdown": {
                        "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                        "label": "force_shutdown",
                        "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "conn_congestion": {
                        "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                        "label": "conn_congestion",
                        "$ref": "#/components/schemas/zone.conn_congestion"
                    },
                    "force_gc": {
                        "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                        "label": "force_gc",
                        "$ref": "#/components/schemas/zone.force_gc"
                    },
                    "overload_protection": {
                        "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                        "label": "overload_protection",
                        "$ref": "#/components/schemas/zone.overload_protection"
                    }
                },
                "type": "object"
            },
            "broker.persistent_session_builtin": {
                "properties": {
                    "type": {
                        "default": "builtin",
                        "description": "",
                        "label": "type",
                        "symbols": [
                            "builtin"
                        ],
                        "type": "enum"
                    },
                    "session": {
                        "description": "Performance tuning options for built-in session table.",
                        "label": "Persistent session",
                        "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
                    },
                    "session_messages": {
                        "description": "Performance tuning options for built-in session messages table.",
                        "label": "Persistent session messages",
                        "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
                    },
                    "messages": {
                        "description": "Performance tuning options for built-in messages table.",
                        "label": "Persistent messages",
                        "$ref": "#/components/schemas/broker.persistent_table_mria_opts"
                    }
                },
                "type": "object"
            },
            "authn-redis.standalone": {
                "required": [
                    "database",
                    "redis_type",
                    "server",
                    "cmd",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "redis"
                        ],
                        "type": "enum"
                    },
                    "cmd": {
                        "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
                        "label": "Command",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "server": {
                        "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The Redis default port 6379 is used if `[:Port]` is not specified.</br>",
                        "label": "Server Host",
                        "type": "ip_port"
                    },
                    "redis_type": {
                        "description": "Single mode",
                        "label": "Single Mode",
                        "symbols": [
                            "single"
                        ],
                        "type": "enum"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "database": {
                        "default": 0,
                        "description": "Redis database ID.",
                        "label": "Database ID",
                        "type": "number"
                    },
                    "auto_reconnect": {
                        "default": true,
                        "description": "Enable automatic reconnect to the database.",
                        "label": "Auto Reconnect Database",
                        "type": "boolean"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "authn-jwt.public-key": {
                "required": [
                    "mechanism",
                    "algorithm",
                    "use_jwks"
                ],
                "properties": {
                    "use_jwks": {
                        "description": "Whether to use JWKS.",
                        "label": "Whether to Use JWKS",
                        "symbols": [
                            false
                        ],
                        "type": "enum"
                    },
                    "algorithm": {
                        "description": "JWT signing algorithm, Supports HMAC (configured as <code>hmac-based</code>) and RSA, ECDSA (configured as <code>public-key</code>).",
                        "label": "JWT Signing Algorithm",
                        "symbols": [
                            "public-key"
                        ],
                        "type": "enum"
                    },
                    "public_key": {
                        "description": "The public key used to verify the JWT.",
                        "label": "Public Key",
                        "type": "string"
                    },
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "jwt"
                        ],
                        "type": "enum"
                    },
                    "acl_claim_name": {
                        "default": "acl",
                        "description": "JWT claim name to use for getting ACL rules.",
                        "label": "acl_claim_name",
                        "type": "string"
                    },
                    "verify_claims": {
                        "default": {},
                        "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Verify Claims",
                        "type": "array"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-redis.sentinel": {
                "required": [
                    "database",
                    "redis_type",
                    "servers",
                    "cmd",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "redis"
                        ],
                        "type": "enum"
                    },
                    "cmd": {
                        "description": "The Redis Command used to query data for authentication such as password hash, currently only supports <code>HGET</code> and <code>HMGET</code>.",
                        "label": "Command",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "servers": {
                        "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Servers",
                        "type": "array"
                    },
                    "redis_type": {
                        "description": "Sentinel mode",
                        "label": "Sentinel Mode",
                        "symbols": [
                            "sentinel"
                        ],
                        "type": "enum"
                    },
                    "sentinel": {
                        "description": "The cluster name in Redis sentinel mode.",
                        "label": "Cluster Name",
                        "type": "string"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "database": {
                        "default": 0,
                        "description": "Redis database ID.",
                        "label": "Database ID",
                        "type": "number"
                    },
                    "auto_reconnect": {
                        "default": true,
                        "description": "Enable automatic reconnect to the database.",
                        "label": "Auto Reconnect Database",
                        "type": "boolean"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "broker.ssl_client_opts": {
                "properties": {
                    "cacertfile": {
                        "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
                        "label": "CACertfile",
                        "type": "string"
                    },
                    "certfile": {
                        "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
                        "label": "Certfile",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "</br>PEM format private key file.</br>",
                        "label": "Keyfile",
                        "type": "string"
                    },
                    "verify": {
                        "default": "verify_none",
                        "description": "</br>Enable or disable peer verification.</br>",
                        "label": "Verify peer",
                        "symbols": [
                            "verify_peer",
                            "verify_none"
                        ],
                        "type": "enum"
                    },
                    "reuse_sessions": {
                        "default": true,
                        "description": "</br>Enable TLS session reuse.</br>",
                        "label": "TLS session reuse",
                        "type": "boolean"
                    },
                    "depth": {
                        "default": 10,
                        "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
                        "label": "CACert Depth",
                        "type": "number"
                    },
                    "password": {
                        "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
                        "example": "",
                        "label": "Keyfile passphrase",
                        "type": "string"
                    },
                    "versions": {
                        "default": [
                            "tlsv1.3",
                            "tlsv1.2",
                            "tlsv1.1",
                            "tlsv1"
                        ],
                        "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "SSL versions",
                        "type": "array"
                    },
                    "ciphers": {
                        "default": [
                            "TLS_AES_256_GCM_SHA384",
                            "TLS_AES_128_GCM_SHA256",
                            "TLS_CHACHA20_POLY1305_SHA256",
                            "TLS_AES_128_CCM_SHA256",
                            "TLS_AES_128_CCM_8_SHA256",
                            "ECDHE-ECDSA-AES256-GCM-SHA384",
                            "ECDHE-RSA-AES256-GCM-SHA384",
                            "ECDHE-ECDSA-AES256-SHA384",
                            "ECDHE-RSA-AES256-SHA384",
                            "ECDH-ECDSA-AES256-GCM-SHA384",
                            "ECDH-RSA-AES256-GCM-SHA384",
                            "ECDH-ECDSA-AES256-SHA384",
                            "ECDH-RSA-AES256-SHA384",
                            "DHE-DSS-AES256-GCM-SHA384",
                            "DHE-DSS-AES256-SHA256",
                            "AES256-GCM-SHA384",
                            "AES256-SHA256",
                            "ECDHE-ECDSA-AES128-GCM-SHA256",
                            "ECDHE-RSA-AES128-GCM-SHA256",
                            "ECDHE-ECDSA-AES128-SHA256",
                            "ECDHE-RSA-AES128-SHA256",
                            "ECDH-ECDSA-AES128-GCM-SHA256",
                            "ECDH-RSA-AES128-GCM-SHA256",
                            "ECDH-ECDSA-AES128-SHA256",
                            "ECDH-RSA-AES128-SHA256",
                            "DHE-DSS-AES128-GCM-SHA256",
                            "DHE-DSS-AES128-SHA256",
                            "AES128-GCM-SHA256",
                            "AES128-SHA256",
                            "ECDHE-ECDSA-AES256-SHA",
                            "ECDHE-RSA-AES256-SHA",
                            "DHE-DSS-AES256-SHA",
                            "ECDH-ECDSA-AES256-SHA",
                            "ECDH-RSA-AES256-SHA",
                            "ECDHE-ECDSA-AES128-SHA",
                            "ECDHE-RSA-AES128-SHA",
                            "DHE-DSS-AES128-SHA",
                            "ECDH-ECDSA-AES128-SHA",
                            "ECDH-RSA-AES128-SHA",
                            "RSA-PSK-AES256-GCM-SHA384",
                            "RSA-PSK-AES256-CBC-SHA384",
                            "RSA-PSK-AES128-GCM-SHA256",
                            "RSA-PSK-AES128-CBC-SHA256",
                            "RSA-PSK-AES256-CBC-SHA",
                            "RSA-PSK-AES128-CBC-SHA"
                        ],
                        "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "",
                        "type": "array"
                    },
                    "user_lookup_fun": {
                        "default": "emqx_tls_psk:lookup",
                        "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
                        "label": "SSL PSK user lookup fun",
                        "type": "string"
                    },
                    "secure_renegotiate": {
                        "default": true,
                        "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
                        "label": "SSL renegotiate",
                        "type": "boolean"
                    },
                    "enable": {
                        "default": false,
                        "description": "</br>Enable TLS.</br>",
                        "label": "Enable TLS.",
                        "type": "boolean"
                    },
                    "server_name_indication": {
                        "description": "</br>Specify the host name to be used in TLS Server Name Indication extension.</br>For instance, when connecting to \"server.example.net\", the genuine server</br>which accepts the connection and performs TLS handshake may differ from the</br>host the TLS client initially connects to, e.g. when connecting to an IP address</br>or when the host has multiple resolvable DNS records </br>If not specified, it will default to the host name string which is used</br>to establish the connection, unless it is IP addressed used.</br>The host name is then also used in the host name verification of the peer</br>certificate.</br> The special value 'disable' prevents the Server Name</br>Indication extension from being sent and disables the hostname</br>verification check.</br>",
                        "example": "disable",
                        "label": "Server Name Indication",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "disable"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "type": "object"
            },
            "zone.overload_protection": {
                "properties": {
                    "enable": {
                        "description": "React on system overload or not",
                        "label": "React on system overload or not",
                        "type": "boolean"
                    },
                    "backoff_delay": {
                        "description": "Some unimportant tasks could be delayed for execution, here set the delays in ms",
                        "label": "Delay Time",
                        "minimum": 0,
                        "type": "number"
                    },
                    "backoff_gc": {
                        "description": "Skip forceful GC if necessary",
                        "label": "Skip GC",
                        "type": "boolean"
                    },
                    "backoff_hibernation": {
                        "description": "Skip process hibernation if necessary",
                        "label": "Skip hibernation",
                        "type": "boolean"
                    },
                    "backoff_new_conn": {
                        "description": "Close new incoming connections if necessary",
                        "label": "Close new connections",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "broker.trace": {
                "properties": {
                    "payload_encode": {
                        "default": "text",
                        "description": "</br>Determine the format of the payload format in the trace file.</br>`text`: Text-based protocol or plain text protocol.</br> It is recommended when payload is JSON encoded.</br>`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.</br>`hidden`: payload is obfuscated as `******`</br></br>",
                        "label": "Payload encode",
                        "symbols": [
                            "hex",
                            "text",
                            "hidden"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "authn-hash.other_algorithms": {
                "required": [
                    "name"
                ],
                "properties": {
                    "name": {
                        "description": "Simple password hashing algorithm.",
                        "label": "name",
                        "symbols": [
                            "plain",
                            "md5",
                            "sha",
                            "sha256",
                            "sha512"
                        ],
                        "type": "enum"
                    },
                    "salt_position": {
                        "default": "prefix",
                        "description": "Salt position for PLAIN, MD5, SHA, SHA256 and SHA512 algorithms.",
                        "label": "salt_position",
                        "symbols": [
                            "disable",
                            "prefix",
                            "suffix"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_call": {
                "properties": {
                    "retry_interval": {
                        "default": "1m",
                        "description": "Time interval to retry after a failed call.",
                        "label": "Cluster Call Retry Interval",
                        "type": "duration"
                    },
                    "max_history": {
                        "default": 100,
                        "description": "Retain the maximum number of completed transactions (for queries).",
                        "label": "Cluster Call Max History",
                        "maximum": 500,
                        "minimum": 1,
                        "type": "number"
                    },
                    "cleanup_interval": {
                        "default": "5m",
                        "description": "Time interval to clear completed but stale transactions.</br>Ensure that the number of completed transactions is less than the <code>max_history</code>.",
                        "label": "Clean Up Interval",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "cluster.log_rotation": {
                "properties": {
                    "enable": {
                        "default": true,
                        "description": "Enable log rotation feature.",
                        "label": "Rotation Enable",
                        "type": "boolean"
                    },
                    "count": {
                        "default": 10,
                        "description": "Maximum number of log files.",
                        "label": "Max Log Files Number",
                        "maximum": 2048,
                        "minimum": 1,
                        "type": "number"
                    }
                },
                "type": "object"
            },
            "broker.sysmon_vm": {
                "properties": {
                    "process_check_interval": {
                        "default": "30s",
                        "description": "The time interval for the periodic process limit check.",
                        "label": "Process limit check interval",
                        "type": "duration"
                    },
                    "process_high_watermark": {
                        "default": "80%",
                        "description": "The threshold, as percentage of processes, for how many</br> processes can simultaneously exist at the local node before the corresponding</br> alarm is raised.",
                        "label": "Process high watermark",
                        "type": "percent"
                    },
                    "process_low_watermark": {
                        "default": "60%",
                        "description": "The threshold, as percentage of processes, for how many</br> processes can simultaneously exist at the local node before the corresponding</br> alarm is cleared.",
                        "label": "Process low watermark",
                        "type": "percent"
                    },
                    "long_gc": {
                        "default": "disabled",
                        "description": "Enable Long GC monitoring.",
                        "label": "Enable Long GC monitoring.",
                        "oneOf": [
                            {
                                "type": "duration"
                            },
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "long_schedule": {
                        "default": "240ms",
                        "description": "Enable Long Schedule monitoring.",
                        "label": "Enable Long Schedule monitoring.",
                        "oneOf": [
                            {
                                "type": "duration"
                            },
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "large_heap": {
                        "default": "32MB",
                        "description": "Enable Large Heap monitoring.",
                        "label": "Enable Large Heap monitoring.",
                        "oneOf": [
                            {
                                "type": "byteSize"
                            },
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "busy_dist_port": {
                        "default": true,
                        "description": "Enable Busy Distribution Port monitoring.",
                        "label": "Enable Busy Distribution Port monitoring.",
                        "type": "boolean"
                    },
                    "busy_port": {
                        "default": true,
                        "description": "Enable Busy Port monitoring.",
                        "label": "Enable Busy Port monitoring.",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "dashboard.listeners": {
                "properties": {
                    "http": {
                        "description": "TCP listeners",
                        "label": "http",
                        "$ref": "#/components/schemas/dashboard.http"
                    },
                    "https": {
                        "description": "SSL listeners",
                        "label": "https",
                        "$ref": "#/components/schemas/dashboard.https"
                    }
                },
                "type": "object"
            },
            "broker.alarm": {
                "properties": {
                    "actions": {
                        "default": [
                            "log",
                            "publish"
                        ],
                        "description": "The actions triggered when the alarm is activated.</br>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.</br><code>log</code> is to write the alarm to log (console or file).</br><code>publish</code> is to publish the alarm as an MQTT message to the system topics:</br><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and</br><code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
                        "example": [
                            "log",
                            "publish"
                        ],
                        "items": {
                            "type": "string"
                        },
                        "label": "Alarm Actions",
                        "type": "array"
                    },
                    "size_limit": {
                        "default": 1000,
                        "description": "The maximum total number of deactivated alarms to keep as history.</br>When this limit is exceeded, the oldest deactivated alarms are deleted to cap the total number.</br>",
                        "example": 1000,
                        "label": "Alarm size limit",
                        "maximum": 3000,
                        "minimum": 1,
                        "type": "number"
                    },
                    "validity_period": {
                        "default": "24h",
                        "description": "Retention time of deactivated alarms. Alarms are not deleted immediately</br>when deactivated, but after the retention time.</br>",
                        "example": "24h",
                        "label": "Alarm validity period",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "broker.persistent_session_store": {
                "properties": {
                    "enabled": {
                        "default": false,
                        "description": "Use the database to store information about persistent sessions.</br>This makes it possible to migrate a client connection to another</br>cluster node if a node is stopped.</br>",
                        "label": "Enable persistent session store",
                        "type": "boolean"
                    },
                    "on_disc": {
                        "default": true,
                        "description": "Save information about the persistent sessions on disc.</br>If this option is enabled, persistent sessions will survive full restart of the cluster.</br>Otherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped.",
                        "label": "Persist on disc",
                        "type": "boolean"
                    },
                    "ram_cache": {
                        "default": false,
                        "description": "Maintain a copy of the data in RAM for faster access.",
                        "label": "RAM cache",
                        "type": "boolean"
                    },
                    "backend": {
                        "default": {
                            "messages": {
                                "ram_cache": "false"
                            },
                            "session": {
                                "ram_cache": "true"
                            },
                            "session_messages": {
                                "ram_cache": "true"
                            },
                            "type": "builtin"
                        },
                        "description": "Database management system used to store information about persistent sessions and messages.</br>- `builtin`: Use the embedded database (mria)",
                        "label": "Backend",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/broker.persistent_session_builtin"
                            }
                        ]
                    },
                    "max_retain_undelivered": {
                        "default": "1h",
                        "description": "The time messages that was not delivered to a persistent session</br>is stored before being garbage collected if the node the previous</br>session was handled on restarts of is stopped.</br>",
                        "label": "Max retain undelivered",
                        "type": "duration"
                    },
                    "message_gc_interval": {
                        "default": "1h",
                        "description": "The starting interval for garbage collection of undelivered messages to</br>a persistent session. This affects how often the \"max_retain_undelivered\"</br>is checked for removal.</br>",
                        "label": "Message GC interval",
                        "type": "duration"
                    },
                    "session_message_gc_interval": {
                        "default": "1m",
                        "description": "The starting interval for garbage collection of transient data for</br>persistent session messages. This does not affect the lifetime length</br>of persistent session messages.</br>",
                        "label": "Session message GC interval",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "authn-http.get": {
                "required": [
                    "url",
                    "backend",
                    "mechanism",
                    "method"
                ],
                "properties": {
                    "method": {
                        "default": "get",
                        "description": "HTTP request method.",
                        "label": "Request Method",
                        "symbols": [
                            "get"
                        ],
                        "type": "enum"
                    },
                    "headers": {
                        "default": {
                            "accept": "application/json",
                            "cache-control": "no-cache",
                            "connection": "keep-alive",
                            "keep-alive": "timeout=30, max=1000"
                        },
                        "description": "List of HTTP headers (without <code>content-type</code>).",
                        "label": "headers_no_content_type",
                        "type": "string"
                    },
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "http"
                        ],
                        "type": "enum"
                    },
                    "url": {
                        "description": "URL of the HTTP server.",
                        "label": "URL",
                        "type": "string"
                    },
                    "body": {
                        "description": "HTTP request body.",
                        "label": "Request Body",
                        "type": "string"
                    },
                    "request_timeout": {
                        "default": "5s",
                        "description": "HTTP request timeout.",
                        "label": "Request Timeout",
                        "type": "duration"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "connect_timeout": {
                        "default": "15s",
                        "description": "The timeout when connecting to the HTTP server.",
                        "label": "Connect Timeout",
                        "type": "duration"
                    },
                    "enable_pipelining": {
                        "default": 100,
                        "description": "Whether to send HTTP requests continuously, when set to 0, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
                        "label": "HTTP Pipelineing",
                        "type": "string"
                    },
                    "max_retries": {
                        "default": 5,
                        "description": "Max retry times if error on sending request.",
                        "label": "Max Retries",
                        "minimum": 1,
                        "type": "number"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "The pool size.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "request": {
                        "description": "</br>If the request is provided, the caller can send HTTP requests via</br><code>emqx_resource:query(ResourceId, {send_message, BridgeId, Message})</code></br>",
                        "label": "Request",
                        "$ref": "#/components/schemas/connector-http.request"
                    },
                    "retry_interval": {
                        "default": "1s",
                        "description": "Interval between retries.",
                        "label": "Retry Interval",
                        "type": "duration"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "broker.broker": {
                "properties": {
                    "enable_session_registry": {
                        "default": true,
                        "description": "Enable session registry",
                        "label": "enable_session_registry",
                        "type": "boolean"
                    },
                    "session_locking_strategy": {
                        "default": "quorum",
                        "description": "Session locking strategy in a cluster.</br>  - `local`: only lock the session on the current node</br>  - `one`: select only one remote node to lock the session</br>  - `quorum`: select some nodes to lock the session</br>  - `all`: lock the session on all the nodes in the cluster</br>",
                        "label": "session_locking_strategy",
                        "symbols": [
                            "local",
                            "leader",
                            "quorum",
                            "all"
                        ],
                        "type": "enum"
                    },
                    "shared_subscription_strategy": {
                        "default": "round_robin",
                        "description": "Dispatch strategy for shared subscription.</br>  - `random`: dispatch the message to a random selected subscriber</br>  - `round_robin`: select the subscribers in a round-robin manner</br>  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.</br>  - `hash`: select the subscribers by the hash of `clientIds`</br>",
                        "label": "shared_subscription_strategy",
                        "symbols": [
                            "random",
                            "round_robin",
                            "sticky",
                            "local",
                            "hash_topic",
                            "hash_clientid"
                        ],
                        "type": "enum"
                    },
                    "shared_dispatch_ack_enabled": {
                        "default": false,
                        "description": "Enable/disable shared dispatch acknowledgement for QoS 1 and QoS 2 messages.</br>This should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.</br>",
                        "label": "shared_dispatch_ack_enabled",
                        "type": "boolean"
                    },
                    "route_batch_clean": {
                        "default": true,
                        "description": "Enable batch clean for deleted routes.",
                        "label": "route_batch_clean",
                        "type": "boolean"
                    },
                    "perf": {
                        "description": "perf Description",
                        "label": "perf",
                        "$ref": "#/components/schemas/broker.broker_perf"
                    },
                    "shared_subscription_group": {
                        "description": "Per group dispatch strategy for shared subscription.</br>This config is a map from shared subscription group name to the strategy</br>name. The group name should be of format `[A-Za-z0-9]`. i.e. no</br>special characters are allowed.</br>",
                        "example": {
                            "example_group": {
                                "strategy": "random"
                            }
                        },
                        "label": "shared_subscription_group",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.shared_subscription_group"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "limiter.client_bucket": {
                "properties": {
                    "rate": {
                        "default": "infinity",
                        "description": "Rate for this bucket.",
                        "label": "Rate",
                        "type": "string"
                    },
                    "initial": {
                        "default": "0",
                        "description": "The initial number of tokens for this bucket.",
                        "label": "Initial",
                        "type": "string"
                    },
                    "low_watermark": {
                        "default": "0",
                        "description": "If the remaining tokens are lower than this value,</br>the check/consume will succeed, but it will be forced to wait for a short period of time.",
                        "label": "Low Watermark",
                        "type": "string"
                    },
                    "capacity": {
                        "default": "infinity",
                        "description": "The capacity of per user.",
                        "label": "Capacity",
                        "type": "string"
                    },
                    "divisible": {
                        "default": false,
                        "description": "Is it possible to split the number of requested tokens?",
                        "label": "Divisible",
                        "type": "boolean"
                    },
                    "max_retry_time": {
                        "default": "10s",
                        "description": "The maximum retry time when acquire failed.",
                        "label": "Max Retry Time",
                        "type": "duration"
                    },
                    "failure_strategy": {
                        "default": "force",
                        "description": "The strategy when all the retries failed.",
                        "label": "Failure Strategy",
                        "symbols": [
                            "force",
                            "drop",
                            "throw"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "authn-postgresql.authentication": {
                "required": [
                    "database",
                    "server",
                    "query",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "postgresql"
                        ],
                        "type": "enum"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "query": {
                        "description": "SQL used to query data for authentication, such as password hash.",
                        "label": "Query",
                        "type": "string"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "server": {
                        "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The PostgreSQL default port 5432 is used if `[:Port]` is not specified.</br>",
                        "label": "Server Host",
                        "type": "ip_port"
                    },
                    "database": {
                        "description": "Database name.",
                        "label": "Database Name",
                        "type": "string"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "username": {
                        "description": "EMQX's username in the external database.",
                        "label": "Username",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "auto_reconnect": {
                        "default": true,
                        "description": "Enable automatic reconnect to the database.",
                        "label": "Auto Reconnect Database",
                        "type": "boolean"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "authn-jwt.jwks": {
                "required": [
                    "mechanism",
                    "endpoint",
                    "use_jwks"
                ],
                "properties": {
                    "use_jwks": {
                        "description": "Whether to use JWKS.",
                        "label": "Whether to Use JWKS",
                        "symbols": [
                            true
                        ],
                        "type": "enum"
                    },
                    "endpoint": {
                        "description": "JWKS endpoint, it's a read-only endpoint that returns the server's public key set in the JWKS format.",
                        "label": "JWKS Endpoint",
                        "type": "string"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "refresh_interval": {
                        "default": 300,
                        "description": "JWKS refresh interval.",
                        "label": "JWKS Refresh Interval",
                        "type": "number"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL options.",
                        "label": "SSL Options",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-jwt.ssl_disable"
                            },
                            {
                                "$ref": "#/components/schemas/authn-jwt.ssl_enable"
                            }
                        ]
                    },
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "jwt"
                        ],
                        "type": "enum"
                    },
                    "acl_claim_name": {
                        "default": "acl",
                        "description": "JWT claim name to use for getting ACL rules.",
                        "label": "acl_claim_name",
                        "type": "string"
                    },
                    "verify_claims": {
                        "default": {},
                        "description": "</br>A list of custom claims to validate, which is a list of name/value pairs.</br>Values can use the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>Authentication will verify that the value of claims in the JWT (taken from the Password field) matches what is required in <code>verify_claims</code>.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Verify Claims",
                        "type": "array"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-mongodb.standalone": {
                "required": [
                    "database",
                    "server",
                    "mongo_type",
                    "collection",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "mongodb"
                        ],
                        "type": "enum"
                    },
                    "collection": {
                        "description": "Collection used to store authentication data.",
                        "label": "Collection",
                        "type": "string"
                    },
                    "filter": {
                        "default": {},
                        "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
                        "label": "Filter",
                        "type": "string"
                    },
                    "password_hash_field": {
                        "default": "password_hash",
                        "description": "Document field that contains password hash.",
                        "label": "Password Hash Field",
                        "type": "string"
                    },
                    "salt_field": {
                        "default": "salt",
                        "description": "Document field that contains the password salt.",
                        "label": "Salt Field",
                        "type": "string"
                    },
                    "is_superuser_field": {
                        "default": "is_superuser",
                        "description": "Document field that defines if the user has superuser privileges.",
                        "label": "Is Superuser Field",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "mongo_type": {
                        "default": "single",
                        "description": "Standalone instance.",
                        "label": "Standalone instance",
                        "symbols": [
                            "single"
                        ],
                        "type": "enum"
                    },
                    "server": {
                        "description": "</br>The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
                        "label": "Server Host",
                        "type": "ip_port"
                    },
                    "w_mode": {
                        "default": "unsafe",
                        "description": "Write mode.",
                        "label": "Write Mode",
                        "symbols": [
                            "unsafe",
                            "safe"
                        ],
                        "type": "enum"
                    },
                    "srv_record": {
                        "default": false,
                        "description": "Use DNS SRV record.",
                        "label": "Srv Record",
                        "type": "boolean"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "username": {
                        "description": "EMQX's username in the external database.",
                        "label": "Username",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "auth_source": {
                        "description": "Database name associated with the user's credentials.",
                        "label": "Auth Source",
                        "type": "string"
                    },
                    "database": {
                        "description": "Database name.",
                        "label": "Database Name",
                        "type": "string"
                    },
                    "topology": {
                        "description": "topology Description",
                        "label": "topology",
                        "$ref": "#/components/schemas/emqx_connector_mongo.topology"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "authn-hash.bcrypt": {
                "required": [
                    "name"
                ],
                "properties": {
                    "name": {
                        "description": "BCRYPT password hashing.",
                        "label": "name",
                        "symbols": [
                            "bcrypt"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "authn-jwt.ssl_disable": {
                "properties": {
                    "enable": {
                        "description": "Enable/disable SSL.",
                        "label": "Enable/disable SSL",
                        "symbols": [
                            false
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "broker.broker_perf": {
                "properties": {
                    "route_lock_type": {
                        "default": "key",
                        "description": "Performance tuning for subscribing/unsubscribing a wildcard topic.</br>Change this parameter only when there are many wildcard topics.</br></br>NOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.</br>  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.</br>  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.</br>  - `global`: updates are protected with a global lock. Recommended for large clusters.</br>",
                        "label": "route_lock_type",
                        "symbols": [
                            "key",
                            "tab",
                            "global"
                        ],
                        "type": "enum"
                    },
                    "trie_compaction": {
                        "default": true,
                        "description": "Enable trie path compaction.</br>Enabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.</br>Topic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.</br></br>NOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.</br>",
                        "label": "trie_compaction",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "broker.mqtt_ws_listener": {
                "required": [
                    "bind"
                ],
                "properties": {
                    "bind": {
                        "default": 8083,
                        "description": "</br>IP address and port for the listening socket.</br>",
                        "label": "IP address and port",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "type": "ip_port"
                            }
                        ]
                    },
                    "acceptors": {
                        "default": 16,
                        "description": "</br>The size of the listener's receiving pool.</br>",
                        "label": "Acceptors Num",
                        "type": "string"
                    },
                    "max_connections": {
                        "default": "infinity",
                        "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
                        "label": "Max connections",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "mountpoint": {
                        "default": "",
                        "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
                        "label": "mountpoint",
                        "type": "string"
                    },
                    "zone": {
                        "default": "default",
                        "description": "</br>The configuration zone to which the listener belongs.</br>",
                        "label": "Zone",
                        "type": "string"
                    },
                    "limiter": {
                        "default": {},
                        "description": "</br>Type of the rate limit.</br>",
                        "label": "Type of the rate limit.",
                        "properties": {
                            "$ratelimit_name": {
                                "type": "string"
                            }
                        },
                        "type": "object"
                    },
                    "access_rules": {
                        "default": [
                            "allow all"
                        ],
                        "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Access rules",
                        "type": "array"
                    },
                    "proxy_protocol": {
                        "default": false,
                        "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
                        "label": "Proxy protocol",
                        "type": "boolean"
                    },
                    "proxy_protocol_timeout": {
                        "default": "3s",
                        "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
                        "label": "Proxy protocol timeout",
                        "type": "duration"
                    },
                    "authentication": {
                        "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
                        "items": {
                            "oneOf": [
                                {
                                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.jwks"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.public-key"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.post"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.get"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.sentinel"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mysql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                                }
                            ]
                        },
                        "label": "Per-listener authentication override",
                        "type": "array"
                    },
                    "tcp_options": {
                        "description": "tcp_options Description",
                        "label": "tcp_options",
                        "$ref": "#/components/schemas/broker.tcp_opts"
                    },
                    "websocket": {
                        "description": "websocket Description",
                        "label": "websocket",
                        "$ref": "#/components/schemas/broker.ws_opts"
                    }
                },
                "type": "object"
            },
            "cluster.cluster": {
                "properties": {
                    "name": {
                        "default": "emqxcl",
                        "description": "Human-friendly name of the EMQX cluster.",
                        "label": "Cluster Name",
                        "readOnly": true,
                        "type": "string"
                    },
                    "discovery_strategy": {
                        "default": "manual",
                        "description": "Service discovery method for the cluster nodes.",
                        "label": "Cluster Discovery Strategy",
                        "readOnly": true,
                        "symbols": [
                            "manual",
                            "static",
                            "mcast",
                            "dns",
                            "etcd",
                            "k8s"
                        ],
                        "type": "enum"
                    },
                    "core_nodes": {
                        "default": "",
                        "description": "</br>List of core nodes that the replicant will connect to.</br>Note: this parameter only takes effect when the <code>backend</code> is set</br>to <code>rlog</code> and the <code>role</code> is set to <code>replicant</code>.</br>This value needs to be defined for manual or static cluster discovery mechanisms.</br>If an automatic cluster discovery mechanism is being used (such as <code>etcd</code>),</br>there is no need to set this value.</br>",
                        "label": "Db Core Node",
                        "readOnly": true,
                        "type": "comma_separated_string"
                    },
                    "autoclean": {
                        "default": "5m",
                        "description": "Remove disconnected nodes from the cluster after this interval.",
                        "label": "Cluster Auto Clean",
                        "readOnly": true,
                        "type": "duration"
                    },
                    "autoheal": {
                        "default": true,
                        "description": "If <code>true</code>, the node will try to heal network partitions automatically.",
                        "label": "Cluster Auto Heal",
                        "readOnly": true,
                        "type": "boolean"
                    },
                    "proto_dist": {
                        "default": "inet_tcp",
                        "description": "The Erlang distribution protocol for the cluster.",
                        "label": "Cluster Protocol Distribution",
                        "readOnly": true,
                        "symbols": [
                            "inet_tcp",
                            "inet6_tcp",
                            "inet_tls"
                        ],
                        "type": "enum"
                    },
                    "static": {
                        "description": "static Description",
                        "label": "static",
                        "$ref": "#/components/schemas/cluster.cluster_static"
                    },
                    "mcast": {
                        "description": "mcast Description",
                        "label": "mcast",
                        "$ref": "#/components/schemas/cluster.cluster_mcast"
                    },
                    "dns": {
                        "description": "dns Description",
                        "label": "dns",
                        "$ref": "#/components/schemas/cluster.cluster_dns"
                    },
                    "etcd": {
                        "description": "etcd Description",
                        "label": "etcd",
                        "$ref": "#/components/schemas/cluster.cluster_etcd"
                    },
                    "k8s": {
                        "description": "k8s Description",
                        "label": "k8s",
                        "$ref": "#/components/schemas/cluster.cluster_k8s"
                    }
                },
                "type": "object"
            },
            "zone.mqtt": {
                "properties": {
                    "idle_timeout": {
                        "description": "After the TCP connection is established, if the MQTT CONNECT packet from the client is not received within the time specified by <code>idle_timeout</code>, the connection will be disconnected.",
                        "label": "Idle Timeout",
                        "oneOf": [
                            {
                                "type": "duration"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "max_packet_size": {
                        "description": "Maximum MQTT packet size allowed.",
                        "label": "Max Packet Size",
                        "type": "byteSize"
                    },
                    "max_clientid_len": {
                        "description": "Maximum allowed length of MQTT Client ID.",
                        "label": "Max Client ID Length",
                        "maximum": 65535,
                        "minimum": 23,
                        "type": "number"
                    },
                    "max_topic_levels": {
                        "description": "Maximum topic levels allowed.",
                        "label": "Max Topic Levels",
                        "maximum": 65535,
                        "minimum": 1,
                        "type": "number"
                    },
                    "max_qos_allowed": {
                        "description": "Maximum QoS allowed.",
                        "label": "Max QoS",
                        "symbols": [
                            0,
                            1,
                            2
                        ],
                        "type": "enum"
                    },
                    "max_topic_alias": {
                        "description": "Maximum topic alias, 0 means no topic alias supported.",
                        "label": "Max Topic Alias",
                        "maximum": 65535,
                        "minimum": 0,
                        "type": "number"
                    },
                    "retain_available": {
                        "description": "Whether to enable support for MQTT retained message.",
                        "label": "Retain Available",
                        "type": "boolean"
                    },
                    "wildcard_subscription": {
                        "description": "Whether to enable support for MQTT wildcard subscription.",
                        "label": "Wildcard Subscription Available",
                        "type": "boolean"
                    },
                    "shared_subscription": {
                        "description": "Whether to enable support for MQTT shared subscription.",
                        "label": "Shared Subscription Available",
                        "type": "boolean"
                    },
                    "ignore_loop_deliver": {
                        "description": "Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0, similar to <code>No Local</code> subscription option in MQTT 5.0",
                        "label": "Ignore Loop Deliver",
                        "type": "boolean"
                    },
                    "strict_mode": {
                        "description": "Parse MQTT messages in strict mode.</br>When set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected",
                        "label": "Strict Mode",
                        "type": "boolean"
                    },
                    "response_information": {
                        "description": "Specify the response information returned to the client. This feature is disabled if is set to \"\". Applies only to clients using MQTT 5.0.",
                        "label": "Response Information",
                        "type": "string"
                    },
                    "server_keepalive": {
                        "description": "The keep alive that EMQX requires the client to use. If configured as <code>disabled</code>, it means that the keep alive specified by the client will be used. Requires <code>Server Keep Alive</code> in MQTT 5.0, so it is only applicable to clients using MQTT 5.0 protocol.",
                        "label": "Server Keep Alive",
                        "oneOf": [
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            },
                            {
                                "type": "number"
                            }
                        ]
                    },
                    "keepalive_backoff": {
                        "description": "The backoff multiplier used by the broker to determine the client keep alive timeout. If EMQX doesn't receive any packet in <code>Keep Alive * Backoff * 2</code> seconds, EMQX will close the current connection.",
                        "label": "Keep Alive Backoff",
                        "type": "number"
                    },
                    "max_subscriptions": {
                        "description": "Maximum number of subscriptions allowed per client.",
                        "label": "Max Subscriptions",
                        "oneOf": [
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            },
                            {
                                "minimum": 1,
                                "type": "number"
                            }
                        ]
                    },
                    "upgrade_qos": {
                        "description": "Force upgrade of QoS level according to subscription.",
                        "label": "Upgrade QoS",
                        "type": "boolean"
                    },
                    "max_inflight": {
                        "description": "Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment.",
                        "label": "Max Inflight",
                        "maximum": 65535,
                        "minimum": 1,
                        "type": "number"
                    },
                    "retry_interval": {
                        "description": "Retry interval for QoS 1/2 message delivering.",
                        "label": "Retry Interval",
                        "type": "duration"
                    },
                    "max_awaiting_rel": {
                        "description": "Maximum QoS 2 packets (Client -> Broker) awaiting PUBREL.",
                        "label": "Max Awaiting PUBREL",
                        "oneOf": [
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            },
                            {
                                "type": "number"
                            }
                        ]
                    },
                    "await_rel_timeout": {
                        "description": "The QoS 2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout.",
                        "label": "Max Awaiting PUBREL TIMEOUT",
                        "type": "duration"
                    },
                    "session_expiry_interval": {
                        "description": "Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections.",
                        "label": "Session Expiry Interval",
                        "type": "duration"
                    },
                    "max_mqueue_len": {
                        "description": "Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full.",
                        "label": "Max Message Queue Length",
                        "oneOf": [
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            },
                            {
                                "minimum": 1,
                                "type": "number"
                            }
                        ]
                    },
                    "mqueue_priorities": {
                        "description": "Topic priorities. Priority number [1-255]</br>There's no priority table by default, hence all messages are treated equal.</br></br>**NOTE**: Comma and equal signs are not allowed for priority topic names.</br>**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.</br></br>**Examples**:</br>To configure <code>\"topic/1\" > \"topic/2\"</code>:</br><code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code></br>",
                        "label": "Topic Priorities",
                        "oneOf": [
                            {
                                "symbols": [
                                    "disabled"
                                ],
                                "type": "enum"
                            },
                            {
                                "type": "string"
                            }
                        ]
                    },
                    "mqueue_default_priority": {
                        "description": "Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>).",
                        "label": "Default Topic Priorities",
                        "symbols": [
                            "highest",
                            "lowest"
                        ],
                        "type": "enum"
                    },
                    "mqueue_store_qos0": {
                        "description": "Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains.",
                        "label": "Store QoS 0 Message",
                        "type": "boolean"
                    },
                    "use_username_as_clientid": {
                        "description": "Whether to user Client ID as Username.</br>This setting takes effect later than <code>Use Peer Certificate as Username</code> (<code>peer_cert_as_username</code>) and <code>Use peer certificate as Client ID</code> (<code>peer_cert_as_clientid</code>).</br>",
                        "label": "Use Username as Client ID",
                        "type": "boolean"
                    },
                    "peer_cert_as_username": {
                        "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.</br>Supported configurations are the following:</br>- <code>cn</code>: Take the CN field of the certificate as Username</br>- <code>dn</code>: Take the DN field of the certificate as Username</br>- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Username</br>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Username</br>- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Username</br>",
                        "label": "Use Peer Certificate as Username",
                        "symbols": [
                            "disabled",
                            "cn",
                            "dn",
                            "crt",
                            "pem",
                            "md5"
                        ],
                        "type": "enum"
                    },
                    "peer_cert_as_clientid": {
                        "description": "Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.</br>Supported configurations are the following:</br>- <code>cn</code>: Take the CN field of the certificate as Client ID</br>- <code>dn</code>: Take the DN field of the certificate as Client ID</br>- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID</br>- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Client ID</br>- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID</br>",
                        "label": "Use Peer Certificate as Client ID",
                        "symbols": [
                            "disabled",
                            "cn",
                            "dn",
                            "crt",
                            "pem",
                            "md5"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "authn-scram-builtin_db.authentication": {
                "required": [
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "scram"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "built_in_database"
                        ],
                        "type": "enum"
                    },
                    "algorithm": {
                        "default": "sha256",
                        "description": "Hashing algorithm.",
                        "label": "algorithm",
                        "symbols": [
                            "sha256",
                            "sha512"
                        ],
                        "type": "enum"
                    },
                    "iteration_count": {
                        "default": 4096,
                        "description": "Iteration count.",
                        "label": "iteration_count",
                        "minimum": 1,
                        "type": "number"
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "cluster.log_overload_kill": {
                "properties": {
                    "enable": {
                        "default": true,
                        "description": "Enable log handler overload kill feature.",
                        "label": "Log Handler Overload Kill",
                        "type": "boolean"
                    },
                    "mem_size": {
                        "default": "30MB",
                        "description": "Maximum memory size that the log handler process is allowed to use.",
                        "label": "Log Handler Max Memory Size",
                        "type": "byteSize"
                    },
                    "qlen": {
                        "default": 20000,
                        "description": "Maximum allowed queue length.",
                        "label": "Max Queue Length",
                        "type": "string"
                    },
                    "restart_after": {
                        "default": "5s",
                        "description": "If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value `infinity` prevents restarts.",
                        "label": "Handler Restart Timer",
                        "oneOf": [
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            },
                            {
                                "type": "duration"
                            }
                        ]
                    }
                },
                "type": "object"
            },
            "zone.conn_congestion": {
                "properties": {
                    "enable_alarm": {
                        "description": "Enable or disable connection congestion alarm.",
                        "label": "Enable/disable congestion alarm",
                        "type": "boolean"
                    },
                    "min_alarm_sustain_duration": {
                        "description": "Minimal time before clearing the alarm.</br></br>The alarm is cleared only when there's no pending data in</br>the queue, and at least `min_alarm_sustain_duration`</br>milliseconds passed since the last time we considered the connection \"congested\".</br></br>This is to avoid clearing and raising the alarm again too often.",
                        "label": "Sustain duration",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "broker.mqtt_quic_listener": {
                "required": [
                    "bind"
                ],
                "properties": {
                    "enabled": {
                        "default": true,
                        "description": "</br>Enable QUIC listener.</br>",
                        "label": "Enable QUIC listener",
                        "type": "boolean"
                    },
                    "certfile": {
                        "description": "</br>Path to the certificate file.</br>",
                        "label": "Certificate file",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "</br>Path to the secret key file.</br>",
                        "label": "Key file",
                        "type": "string"
                    },
                    "ciphers": {
                        "default": [
                            "TLS_AES_256_GCM_SHA384",
                            "TLS_AES_128_GCM_SHA256",
                            "TLS_CHACHA20_POLY1305_SHA256"
                        ],
                        "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br></br>NOTE: QUIC listener supports only 'tlsv1.3' ciphers</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "",
                        "type": "array"
                    },
                    "idle_timeout": {
                        "default": "15s",
                        "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
                        "label": "Idle Timeout",
                        "type": "duration"
                    },
                    "bind": {
                        "default": 14567,
                        "description": "</br>IP address and port for the listening socket.</br>",
                        "label": "IP address and port",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "type": "ip_port"
                            }
                        ]
                    },
                    "acceptors": {
                        "default": 16,
                        "description": "</br>The size of the listener's receiving pool.</br>",
                        "label": "Acceptors Num",
                        "type": "string"
                    },
                    "max_connections": {
                        "default": "infinity",
                        "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
                        "label": "Max connections",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "mountpoint": {
                        "default": "",
                        "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
                        "label": "mountpoint",
                        "type": "string"
                    },
                    "zone": {
                        "default": "default",
                        "description": "</br>The configuration zone to which the listener belongs.</br>",
                        "label": "Zone",
                        "type": "string"
                    },
                    "limiter": {
                        "default": {},
                        "description": "</br>Type of the rate limit.</br>",
                        "label": "Type of the rate limit.",
                        "properties": {
                            "$ratelimit_name": {
                                "type": "string"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "limiter.limiter": {
                "properties": {
                    "bytes_in": {
                        "default": {
                            "enable": false
                        },
                        "description": "The bytes_in limiter.</br>This is used to limit the inbound bytes rate for this EMQX node.</br>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
                        "label": "Bytes In",
                        "$ref": "#/components/schemas/limiter.limiter_opts"
                    },
                    "message_in": {
                        "default": {
                            "enable": false
                        },
                        "description": "The message in limiter.</br>This is used to limit the inbound message numbers for this EMQX node</br>Once the limit is reached, the restricted client will be slow down even be hung for a while.",
                        "label": "Message In",
                        "$ref": "#/components/schemas/limiter.limiter_opts"
                    },
                    "connection": {
                        "default": {
                            "enable": false
                        },
                        "description": "The connection limiter.</br>This is used to limit the connection rate for this EMQX node.</br>Once the limit is reached, new connections will be refused",
                        "label": "Connection",
                        "$ref": "#/components/schemas/limiter.limiter_opts"
                    },
                    "message_routing": {
                        "default": {
                            "enable": false
                        },
                        "description": "The message routing limiter.</br>This is used to limit the forwarding rate for this EMQX node.</br>Once the limit is reached, new publish will be refused",
                        "label": "Message Routing",
                        "$ref": "#/components/schemas/limiter.limiter_opts"
                    },
                    "batch": {
                        "default": {
                            "enable": false
                        },
                        "description": "The batch limiter.</br>This is used for EMQX internal batch operation</br>e.g. limit the retainer's deliver rate",
                        "label": "Batch",
                        "$ref": "#/components/schemas/limiter.limiter_opts"
                    }
                },
                "type": "object"
            },
            "broker.ws_opts": {
                "properties": {
                    "mqtt_path": {
                        "default": "/mqtt",
                        "description": "</br>WebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:</br><code>ws://{ip}:{port}/mqtt</code></br>",
                        "label": "WS MQTT Path",
                        "type": "string"
                    },
                    "mqtt_piggyback": {
                        "default": "multiple",
                        "description": "</br>Whether a WebSocket message is allowed to contain multiple MQTT packets.</br>",
                        "label": "MQTT Piggyback",
                        "symbols": [
                            "single",
                            "multiple"
                        ],
                        "type": "enum"
                    },
                    "compress": {
                        "default": false,
                        "description": "</br>If <code>true</code>, compress WebSocket messages using <code>zlib</code>.</br>The configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.</br>",
                        "label": "Ws compress",
                        "type": "boolean"
                    },
                    "idle_timeout": {
                        "default": "7200s",
                        "description": "</br>Close transport-layer connections from the clients that have not sent MQTT CONNECT</br>message within this interval.</br>",
                        "label": "Idle Timeout",
                        "type": "duration"
                    },
                    "max_frame_size": {
                        "default": "infinity",
                        "description": "</br>The maximum length of a single MQTT packet.</br>",
                        "label": "Max frame size",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "fail_if_no_subprotocol": {
                        "default": true,
                        "description": "</br>If <code>true</code>, the server will return an error when</br> the client does not carry the <code>Sec-WebSocket-Protocol</code> field.</br> </br>Note: WeChat applet needs to disable this verification.</br>",
                        "label": "Fail if no subprotocol",
                        "type": "boolean"
                    },
                    "supported_subprotocols": {
                        "default": "mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5",
                        "description": "</br>Comma-separated list of supported subprotocols.</br>",
                        "label": "Supported subprotocols",
                        "type": "comma_separated_string"
                    },
                    "check_origin_enable": {
                        "default": false,
                        "description": "</br>If <code>true</code>, <code>origin</code> HTTP header will be</br> validated against the list of allowed origins configured in <code>check_origins</code></br> parameter.</br>",
                        "label": "Check origin",
                        "type": "boolean"
                    },
                    "allow_origin_absence": {
                        "default": true,
                        "description": "</br>If <code>false</code> and <code>check_origin_enable</code> is</br> <code>true</code>, the server will reject requests that don't have <code>origin</code></br> HTTP header.</br>",
                        "label": "Allow origin absence",
                        "type": "boolean"
                    },
                    "check_origins": {
                        "default": "",
                        "description": "</br>List of allowed origins.</br>See <code>check_origin_enable</code>.</br>",
                        "example": "http://localhost:18083, http://127.0.0.1:18083",
                        "label": "Allowed origins",
                        "type": "string"
                    },
                    "proxy_address_header": {
                        "default": "x-forwarded-for",
                        "description": "</br>HTTP header used to pass information about the client IP address.</br>Relevant when the EMQX cluster is deployed behind a load-balancer.</br>",
                        "label": "Proxy address header",
                        "type": "string"
                    },
                    "proxy_port_header": {
                        "default": "x-forwarded-port",
                        "description": "</br>HTTP header used to pass information about the client port.</br>Relevant when the EMQX cluster is deployed behind a load-balancer.</br>",
                        "label": "Proxy port header",
                        "type": "string"
                    },
                    "deflate_opts": {
                        "description": "deflate_opts Description",
                        "label": "deflate_opts",
                        "$ref": "#/components/schemas/broker.deflate_opts"
                    }
                },
                "type": "object"
            },
            "dashboard.https": {
                "required": [
                    "bind",
                    "enable"
                ],
                "properties": {
                    "enable": {
                        "default": false,
                        "description": "Ignore or enable this listener",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "bind": {
                        "default": 18084,
                        "description": "Port without IP(18083) or port with specified IP(127.0.0.1:18083).",
                        "example": "0.0.0.0:18084",
                        "label": "Bind",
                        "oneOf": [
                            {
                                "type": "ip_port"
                            },
                            {
                                "minimum": 1,
                                "type": "number"
                            }
                        ]
                    },
                    "num_acceptors": {
                        "default": 4,
                        "description": "Socket acceptor pool size for TCP protocols.",
                        "label": "Number of acceptors",
                        "type": "number"
                    },
                    "max_connections": {
                        "default": 512,
                        "description": "Maximum number of simultaneous connections.",
                        "label": "Maximum connections",
                        "type": "number"
                    },
                    "backlog": {
                        "default": 1024,
                        "description": "Defines the maximum length that the queue of pending connections can grow to.",
                        "label": "Backlog",
                        "type": "number"
                    },
                    "send_timeout": {
                        "default": "5s",
                        "description": "Send timeout for the socket.",
                        "label": "Send timeout",
                        "type": "duration"
                    },
                    "inet6": {
                        "default": false,
                        "description": "Enable IPv6 support, default is false, which means IPv4 only.",
                        "label": "IPv6",
                        "type": "boolean"
                    },
                    "ipv6_v6only": {
                        "default": false,
                        "description": "Disable IPv4-to-IPv6 mapping for the listener.",
                        "label": "IPv6 only",
                        "type": "boolean"
                    },
                    "cacertfile": {
                        "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
                        "label": "CACertfile",
                        "type": "string"
                    },
                    "certfile": {
                        "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
                        "label": "Certfile",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "</br>PEM format private key file.</br>",
                        "label": "Keyfile",
                        "type": "string"
                    },
                    "verify": {
                        "default": "verify_none",
                        "description": "</br>Enable or disable peer verification.</br>",
                        "label": "Verify peer",
                        "symbols": [
                            "verify_peer",
                            "verify_none"
                        ],
                        "type": "enum"
                    },
                    "reuse_sessions": {
                        "default": true,
                        "description": "</br>Enable TLS session reuse.</br>",
                        "label": "TLS session reuse",
                        "type": "boolean"
                    },
                    "depth": {
                        "default": 10,
                        "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
                        "label": "CACert Depth",
                        "type": "number"
                    },
                    "password": {
                        "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
                        "example": "",
                        "label": "Keyfile passphrase",
                        "type": "string"
                    },
                    "versions": {
                        "default": [
                            "tlsv1.3",
                            "tlsv1.2",
                            "tlsv1.1",
                            "tlsv1"
                        ],
                        "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "SSL versions",
                        "type": "array"
                    },
                    "ciphers": {
                        "default": [
                            "TLS_AES_256_GCM_SHA384",
                            "TLS_AES_128_GCM_SHA256",
                            "TLS_CHACHA20_POLY1305_SHA256",
                            "TLS_AES_128_CCM_SHA256",
                            "TLS_AES_128_CCM_8_SHA256",
                            "ECDHE-ECDSA-AES256-GCM-SHA384",
                            "ECDHE-RSA-AES256-GCM-SHA384",
                            "ECDHE-ECDSA-AES256-SHA384",
                            "ECDHE-RSA-AES256-SHA384",
                            "ECDH-ECDSA-AES256-GCM-SHA384",
                            "ECDH-RSA-AES256-GCM-SHA384",
                            "ECDH-ECDSA-AES256-SHA384",
                            "ECDH-RSA-AES256-SHA384",
                            "DHE-DSS-AES256-GCM-SHA384",
                            "DHE-DSS-AES256-SHA256",
                            "AES256-GCM-SHA384",
                            "AES256-SHA256",
                            "ECDHE-ECDSA-AES128-GCM-SHA256",
                            "ECDHE-RSA-AES128-GCM-SHA256",
                            "ECDHE-ECDSA-AES128-SHA256",
                            "ECDHE-RSA-AES128-SHA256",
                            "ECDH-ECDSA-AES128-GCM-SHA256",
                            "ECDH-RSA-AES128-GCM-SHA256",
                            "ECDH-ECDSA-AES128-SHA256",
                            "ECDH-RSA-AES128-SHA256",
                            "DHE-DSS-AES128-GCM-SHA256",
                            "DHE-DSS-AES128-SHA256",
                            "AES128-GCM-SHA256",
                            "AES128-SHA256",
                            "ECDHE-ECDSA-AES256-SHA",
                            "ECDHE-RSA-AES256-SHA",
                            "DHE-DSS-AES256-SHA",
                            "ECDH-ECDSA-AES256-SHA",
                            "ECDH-RSA-AES256-SHA",
                            "ECDHE-ECDSA-AES128-SHA",
                            "ECDHE-RSA-AES128-SHA",
                            "DHE-DSS-AES128-SHA",
                            "ECDH-ECDSA-AES128-SHA",
                            "ECDH-RSA-AES128-SHA",
                            "RSA-PSK-AES256-GCM-SHA384",
                            "RSA-PSK-AES256-CBC-SHA384",
                            "RSA-PSK-AES128-GCM-SHA256",
                            "RSA-PSK-AES128-CBC-SHA256",
                            "RSA-PSK-AES256-CBC-SHA",
                            "RSA-PSK-AES128-CBC-SHA"
                        ],
                        "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "",
                        "type": "array"
                    },
                    "user_lookup_fun": {
                        "default": "emqx_tls_psk:lookup",
                        "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
                        "label": "SSL PSK user lookup fun",
                        "type": "string"
                    },
                    "secure_renegotiate": {
                        "default": true,
                        "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
                        "label": "SSL renegotiate",
                        "type": "boolean"
                    },
                    "dhfile": {
                        "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
                        "label": "SSL dhfile",
                        "type": "string"
                    },
                    "honor_cipher_order": {
                        "default": true,
                        "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
                        "label": "SSL honor cipher order",
                        "type": "boolean"
                    },
                    "client_renegotiation": {
                        "default": true,
                        "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
                        "label": "SSL client renegotiation",
                        "type": "boolean"
                    },
                    "handshake_timeout": {
                        "default": "15s",
                        "description": "</br>Maximum time duration allowed for the handshake to complete</br>",
                        "label": "Handshake timeout",
                        "type": "duration"
                    }
                },
                "type": "object"
            },
            "limiter.limiter_opts": {
                "properties": {
                    "enable": {
                        "default": true,
                        "description": "Enable",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "rate": {
                        "default": "infinity",
                        "description": "Rate for this bucket.",
                        "label": "Rate",
                        "type": "string"
                    },
                    "burst": {
                        "default": 0,
                        "description": "The burst, This value is based on rate.</br> This value + rate = the maximum limit that can be achieved when limiter burst.",
                        "label": "Burst",
                        "type": "string"
                    },
                    "bucket": {
                        "default": {
                            "default": {}
                        },
                        "description": "Bucket Configs",
                        "example": {
                            "mybucket-name": {
                                "capcity": "infinity",
                                "initial": "100",
                                "per_client": {
                                    "rate": "infinity"
                                },
                                "rate": "infinity"
                            }
                        },
                        "label": "Buckets",
                        "properties": {
                            "$bucket_name": {
                                "$ref": "#/components/schemas/limiter.bucket_opts"
                            }
                        },
                        "type": "object"
                    }
                },
                "type": "object"
            },
            "broker.mqtt_wss_listener": {
                "required": [
                    "bind"
                ],
                "properties": {
                    "bind": {
                        "default": 8084,
                        "description": "</br>IP address and port for the listening socket.</br>",
                        "label": "IP address and port",
                        "oneOf": [
                            {
                                "type": "number"
                            },
                            {
                                "type": "ip_port"
                            }
                        ]
                    },
                    "acceptors": {
                        "default": 16,
                        "description": "</br>The size of the listener's receiving pool.</br>",
                        "label": "Acceptors Num",
                        "type": "string"
                    },
                    "max_connections": {
                        "default": "infinity",
                        "description": "</br>The maximum number of concurrent connections allowed by the listener.</br>",
                        "label": "Max connections",
                        "oneOf": [
                            {
                                "type": "string"
                            },
                            {
                                "symbols": [
                                    "infinity"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "mountpoint": {
                        "default": "",
                        "description": "</br>When publishing or subscribing, prefix all topics with a mountpoint string.</br>The prefixed string will be removed from the topic name when the message</br>is delivered to the subscriber. The mountpoint is a way that users can use</br>to implement isolation of message routing between different listeners.</br>For example if a client A subscribes to `t` with `listeners.tcp.<name>.mountpoint`</br>set to `some_tenant`, then the client actually subscribes to the topic</br>`some_tenant/t`. Similarly, if another client B (connected to the same listener</br>as the client A) sends a message to topic `t`, the message is routed</br>to all the clients subscribed `some_tenant/t`, so client A will receive the</br>message, with topic name `t`.</br>Set to `\"\"` to disable the feature.</br></br>Variables in mountpoint string:</br>  - <code>${clientid}</code>: clientid</br>  - <code>${username}</code>: username</br>",
                        "label": "mountpoint",
                        "type": "string"
                    },
                    "zone": {
                        "default": "default",
                        "description": "</br>The configuration zone to which the listener belongs.</br>",
                        "label": "Zone",
                        "type": "string"
                    },
                    "limiter": {
                        "default": {},
                        "description": "</br>Type of the rate limit.</br>",
                        "label": "Type of the rate limit.",
                        "properties": {
                            "$ratelimit_name": {
                                "type": "string"
                            }
                        },
                        "type": "object"
                    },
                    "access_rules": {
                        "default": [
                            "allow all"
                        ],
                        "description": "</br>The access control rules for this listener.</br>See: https://github.com/emqtt/esockd#allowdeny</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Access rules",
                        "type": "array"
                    },
                    "proxy_protocol": {
                        "default": false,
                        "description": "</br>Enable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.</br>See: https://www.haproxy.com/blog/haproxy/proxy-protocol/</br>",
                        "label": "Proxy protocol",
                        "type": "boolean"
                    },
                    "proxy_protocol_timeout": {
                        "default": "3s",
                        "description": "</br>Timeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.</br>",
                        "label": "Proxy protocol timeout",
                        "type": "duration"
                    },
                    "authentication": {
                        "description": "</br>Per-listener authentication override.</br>Authentication can be one single authenticator instance or a chain of authenticators as an array.</br>When authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.</br></br>",
                        "items": {
                            "oneOf": [
                                {
                                    "$ref": "#/components/schemas/authn-scram-builtin_db.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.jwks"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.public-key"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-jwt.hmac-based"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.post"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-http.get"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.sentinel"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-redis.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.sharded-cluster"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.replica-set"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mongodb.standalone"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-postgresql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-mysql.authentication"
                                },
                                {
                                    "$ref": "#/components/schemas/authn-builtin_db.authentication"
                                }
                            ]
                        },
                        "label": "Per-listener authentication override",
                        "type": "array"
                    },
                    "tcp_options": {
                        "description": "tcp_options Description",
                        "label": "tcp_options",
                        "$ref": "#/components/schemas/broker.tcp_opts"
                    },
                    "ssl_options": {
                        "description": "ssl_options Description",
                        "label": "ssl_options",
                        "$ref": "#/components/schemas/broker.listener_wss_opts"
                    },
                    "websocket": {
                        "description": "websocket Description",
                        "label": "websocket",
                        "$ref": "#/components/schemas/broker.ws_opts"
                    }
                },
                "type": "object"
            },
            "authn-builtin_db.authentication": {
                "required": [
                    "user_id_type",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "built_in_database"
                        ],
                        "type": "enum"
                    },
                    "user_id_type": {
                        "default": "username",
                        "description": "Specify whether to use `clientid` or `username` for authentication.",
                        "label": "Authentication ID Type",
                        "symbols": [
                            "clientid",
                            "username"
                        ],
                        "type": "enum"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash creation and verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt_rw"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-jwt.ssl_enable": {
                "properties": {
                    "enable": {
                        "description": "Enable/disable SSL.",
                        "label": "Enable/disable SSL",
                        "symbols": [
                            true
                        ],
                        "type": "enum"
                    },
                    "cacertfile": {
                        "description": "Path to a file containing PEM-encoded CA certificates.",
                        "label": "CA Certificate File",
                        "type": "string"
                    },
                    "certfile": {
                        "description": "Path to a file containing the user certificate.",
                        "label": "Certificate File",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "Path to a file containing the user's private PEM-encoded key.",
                        "label": "Key File",
                        "type": "string"
                    },
                    "verify": {
                        "default": "verify_none",
                        "description": "Enable or disable SSL peer verification.",
                        "label": "Verify",
                        "symbols": [
                            "verify_peer",
                            "verify_none"
                        ],
                        "type": "enum"
                    },
                    "server_name_indication": {
                        "description": "Server Name Indication (SNI).",
                        "label": "Server Name Indication",
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "limiter.bucket_opts": {
                "properties": {
                    "rate": {
                        "default": "infinity",
                        "description": "Rate for this bucket.",
                        "label": "Rate",
                        "type": "string"
                    },
                    "capacity": {
                        "default": "infinity",
                        "description": "The capacity of this token bucket.",
                        "label": "Capacity",
                        "type": "string"
                    },
                    "initial": {
                        "default": "0",
                        "description": "The initial number of tokens for this bucket.",
                        "label": "Initial",
                        "type": "string"
                    },
                    "per_client": {
                        "default": {},
                        "description": "The rate limit for each user of the bucket, this field is not required",
                        "label": "Per Client",
                        "$ref": "#/components/schemas/limiter.client_bucket"
                    }
                },
                "type": "object"
            },
            "cluster.cluster_etcd": {
                "properties": {
                    "server": {
                        "description": "List of endpoint URLs of the etcd cluster",
                        "label": "Cluster Etcd Server",
                        "readOnly": true,
                        "type": "comma_separated_string"
                    },
                    "prefix": {
                        "default": "emqxcl",
                        "description": "Key prefix used for EMQX service discovery.",
                        "label": "Cluster Etcd Prefix",
                        "readOnly": true,
                        "type": "string"
                    },
                    "node_ttl": {
                        "default": "1m",
                        "description": "Expiration time of the etcd key associated with the node.</br>It is refreshed automatically, as long as the node is alive.</br>          ",
                        "label": "Cluster Etcd Node TTL",
                        "readOnly": true,
                        "type": "duration"
                    },
                    "ssl": {
                        "description": "Options for the TLS connection to the etcd cluster.",
                        "label": "Cluster Etcd SSL Option",
                        "readOnly": true,
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "broker.listener_ssl_opts": {
                "properties": {
                    "cacertfile": {
                        "description": "</br>Trusted PEM format CA certificates bundle file.</br>The certificates in this file are used to verify the TLS peer's certificates.</br>Append new certificates to the file if new CAs are to be trusted.</br>There is no need to restart EMQX to have the updated file loaded, because</br>the system regularly checks if file has been updated (and reload).</br>NOTE: invalidating (deleting) a certificate from the file will not affect</br>already established connections.</br>",
                        "label": "CACertfile",
                        "type": "string"
                    },
                    "certfile": {
                        "description": "</br>PEM format certificates chain file.</br>The certificates in this file should be in reversed order of the certificate</br>issue chain. That is, the host's certificate should be placed in the beginning</br>of the file, followed by the immediate issuer certificate and so on.</br>Although the root CA certificate is optional, it should be placed at the end of</br>the file if it is to be added.</br>",
                        "label": "Certfile",
                        "type": "string"
                    },
                    "keyfile": {
                        "description": "</br>PEM format private key file.</br>",
                        "label": "Keyfile",
                        "type": "string"
                    },
                    "verify": {
                        "default": "verify_none",
                        "description": "</br>Enable or disable peer verification.</br>",
                        "label": "Verify peer",
                        "symbols": [
                            "verify_peer",
                            "verify_none"
                        ],
                        "type": "enum"
                    },
                    "reuse_sessions": {
                        "default": true,
                        "description": "</br>Enable TLS session reuse.</br>",
                        "label": "TLS session reuse",
                        "type": "boolean"
                    },
                    "depth": {
                        "default": 10,
                        "description": "</br>Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path. So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly; if 1 the path can be PEER, CA, ROOT-CA; if 2 the path can be PEER, CA, CA, ROOT-CA, and so on. The default value is 10.</br>",
                        "label": "CACert Depth",
                        "type": "number"
                    },
                    "password": {
                        "description": "</br>String containing the user's password.</br>Only used if the private key file is password-protected.</br>",
                        "example": "",
                        "label": "Keyfile passphrase",
                        "type": "string"
                    },
                    "versions": {
                        "default": [
                            "tlsv1.3",
                            "tlsv1.2",
                            "tlsv1.1",
                            "tlsv1"
                        ],
                        "description": "</br>All TLS/DTLS versions to be supported.</br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.</br>In case PSK cipher suites are intended, make sure to configured</br><code>['tlsv1.2', 'tlsv1.1']</code> here.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "SSL versions",
                        "type": "array"
                    },
                    "ciphers": {
                        "default": [
                            "TLS_AES_256_GCM_SHA384",
                            "TLS_AES_128_GCM_SHA256",
                            "TLS_CHACHA20_POLY1305_SHA256",
                            "TLS_AES_128_CCM_SHA256",
                            "TLS_AES_128_CCM_8_SHA256",
                            "ECDHE-ECDSA-AES256-GCM-SHA384",
                            "ECDHE-RSA-AES256-GCM-SHA384",
                            "ECDHE-ECDSA-AES256-SHA384",
                            "ECDHE-RSA-AES256-SHA384",
                            "ECDH-ECDSA-AES256-GCM-SHA384",
                            "ECDH-RSA-AES256-GCM-SHA384",
                            "ECDH-ECDSA-AES256-SHA384",
                            "ECDH-RSA-AES256-SHA384",
                            "DHE-DSS-AES256-GCM-SHA384",
                            "DHE-DSS-AES256-SHA256",
                            "AES256-GCM-SHA384",
                            "AES256-SHA256",
                            "ECDHE-ECDSA-AES128-GCM-SHA256",
                            "ECDHE-RSA-AES128-GCM-SHA256",
                            "ECDHE-ECDSA-AES128-SHA256",
                            "ECDHE-RSA-AES128-SHA256",
                            "ECDH-ECDSA-AES128-GCM-SHA256",
                            "ECDH-RSA-AES128-GCM-SHA256",
                            "ECDH-ECDSA-AES128-SHA256",
                            "ECDH-RSA-AES128-SHA256",
                            "DHE-DSS-AES128-GCM-SHA256",
                            "DHE-DSS-AES128-SHA256",
                            "AES128-GCM-SHA256",
                            "AES128-SHA256",
                            "ECDHE-ECDSA-AES256-SHA",
                            "ECDHE-RSA-AES256-SHA",
                            "DHE-DSS-AES256-SHA",
                            "ECDH-ECDSA-AES256-SHA",
                            "ECDH-RSA-AES256-SHA",
                            "ECDHE-ECDSA-AES128-SHA",
                            "ECDHE-RSA-AES128-SHA",
                            "DHE-DSS-AES128-SHA",
                            "ECDH-ECDSA-AES128-SHA",
                            "ECDH-RSA-AES128-SHA",
                            "RSA-PSK-AES256-GCM-SHA384",
                            "RSA-PSK-AES256-CBC-SHA384",
                            "RSA-PSK-AES128-GCM-SHA256",
                            "RSA-PSK-AES128-CBC-SHA256",
                            "RSA-PSK-AES256-CBC-SHA",
                            "RSA-PSK-AES128-CBC-SHA"
                        ],
                        "description": "</br>This config holds TLS cipher suite names separated by comma,</br>or as an array of strings. e.g.</br><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or</br><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.</br></br>Ciphers (and their ordering) define the way in which the</br>client and server encrypts information over the network connection.</br>Selecting a good cipher suite is critical for the</br>application's data security, confidentiality and performance.</br></br>The names should be in OpenSSL string format (not RFC format).</br>All default values and examples provided by EMQX config</br>documentation are all in OpenSSL format.</br></br>NOTE: Certain cipher suites are only compatible with</br>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')</br>incompatible cipher suites will be silently dropped.</br>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,</br>configuring cipher suites for other versions will have no effect.</br></br></br>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config</br>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.</br>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,</br>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,</br>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,</br>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code></br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "",
                        "type": "array"
                    },
                    "user_lookup_fun": {
                        "default": "emqx_tls_psk:lookup",
                        "description": "</br>EMQX-internal callback that is used to lookup pre-shared key (PSK) identity.</br>",
                        "label": "SSL PSK user lookup fun",
                        "type": "string"
                    },
                    "secure_renegotiate": {
                        "default": true,
                        "description": "</br>SSL parameter renegotiation is a feature that allows a client and a server</br>to renegotiate the parameters of the SSL connection on the fly.</br>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,</br>you drop support for the insecure renegotiation, prone to MitM attacks.</br>",
                        "label": "SSL renegotiate",
                        "type": "boolean"
                    },
                    "dhfile": {
                        "description": "</br>Path to a file containing PEM-encoded Diffie-Hellman parameters</br>to be used by the server if a cipher suite using Diffie-Hellman</br>key exchange is negotiated. If not specified, default parameters</br>are used.</br>NOTE: The <code>dhfile</code> option is not supported by TLS 1.3.</br>",
                        "label": "SSL dhfile",
                        "type": "string"
                    },
                    "fail_if_no_peer_cert": {
                        "default": false,
                        "description": "</br>Used together with {verify, verify_peer} by an TLS/DTLS server.</br>If set to true, the server fails if the client does not have a</br>certificate to send, that is, sends an empty certificate.</br>If set to false, it fails only if the client sends an invalid</br>certificate (an empty certificate is considered valid).</br>",
                        "label": "SSL fail if no peer cert",
                        "type": "boolean"
                    },
                    "honor_cipher_order": {
                        "default": true,
                        "description": "</br>An important security setting, it forces the cipher to be set based</br> on the server-specified order instead of the client-specified order,</br> hence enforcing the (usually more properly configured) security</br> ordering of the server administrator.</br>",
                        "label": "SSL honor cipher order",
                        "type": "boolean"
                    },
                    "client_renegotiation": {
                        "default": true,
                        "description": "</br>In protocols that support client-initiated renegotiation,</br>the cost of resources of such an operation is higher for the server than the client.</br>This can act as a vector for denial of service attacks.</br>The SSL application already takes measures to counter-act such attempts,</br>but client-initiated renegotiation can be strictly disabled by setting this option to false.</br>The default value is true. Note that disabling renegotiation can result in</br>long-lived connections becoming unusable due to limits on</br>the number of messages the underlying cipher suite can encipher.</br>",
                        "label": "SSL client renegotiation",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "broker.persistent_table_mria_opts": {
                "properties": {
                    "ram_cache": {
                        "default": true,
                        "description": "Maintain a copy of the data in RAM for faster access.",
                        "label": "RAM cache",
                        "type": "boolean"
                    }
                },
                "type": "object"
            },
            "authn-hash.pbkdf2": {
                "required": [
                    "iterations",
                    "mac_fun",
                    "name"
                ],
                "properties": {
                    "name": {
                        "description": "PBKDF2 password hashing.",
                        "label": "name",
                        "symbols": [
                            "pbkdf2"
                        ],
                        "type": "enum"
                    },
                    "mac_fun": {
                        "description": "Specifies mac_fun for PBKDF2 hashing algorithm.",
                        "label": "mac_fun",
                        "symbols": [
                            "md4",
                            "md5",
                            "ripemd160",
                            "sha",
                            "sha224",
                            "sha256",
                            "sha384",
                            "sha512"
                        ],
                        "type": "enum"
                    },
                    "iterations": {
                        "description": "Iteration count for PBKDF2 hashing algorithm.",
                        "label": "iterations",
                        "type": "number"
                    },
                    "dk_length": {
                        "description": "Derived length for PBKDF2 hashing algorithm. If not specified, calculated automatically based on `mac_fun`.",
                        "label": "dk_length",
                        "type": "number"
                    }
                },
                "type": "object"
            },
            "authn-mongodb.sharded-cluster": {
                "required": [
                    "database",
                    "servers",
                    "mongo_type",
                    "collection",
                    "backend",
                    "mechanism"
                ],
                "properties": {
                    "mechanism": {
                        "description": "Authentication mechanism.",
                        "label": "Authentication Mechanism",
                        "symbols": [
                            "password_based"
                        ],
                        "type": "enum"
                    },
                    "backend": {
                        "description": "Backend type.",
                        "label": "Backend Type",
                        "symbols": [
                            "mongodb"
                        ],
                        "type": "enum"
                    },
                    "collection": {
                        "description": "Collection used to store authentication data.",
                        "label": "Collection",
                        "type": "string"
                    },
                    "filter": {
                        "default": {},
                        "description": "</br>Conditional expression that defines the filter condition in the query.</br>Filter supports the following placeholders:</br>- <code>${username}</code>: Will be replaced at runtime with <code>Username</code> used by the client when connecting</br>- <code>${clientid}</code>: Will be replaced at runtime with <code>Client ID</code> used by the client when connecting</br>",
                        "label": "Filter",
                        "type": "string"
                    },
                    "password_hash_field": {
                        "default": "password_hash",
                        "description": "Document field that contains password hash.",
                        "label": "Password Hash Field",
                        "type": "string"
                    },
                    "salt_field": {
                        "default": "salt",
                        "description": "Document field that contains the password salt.",
                        "label": "Salt Field",
                        "type": "string"
                    },
                    "is_superuser_field": {
                        "default": "is_superuser",
                        "description": "Document field that defines if the user has superuser privileges.",
                        "label": "Is Superuser Field",
                        "type": "string"
                    },
                    "password_hash_algorithm": {
                        "default": {
                            "name": "sha256",
                            "salt_position": "prefix"
                        },
                        "description": "Options for password hash verification.",
                        "label": "password_hash_algorithm",
                        "oneOf": [
                            {
                                "$ref": "#/components/schemas/authn-hash.other_algorithms"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.pbkdf2"
                            },
                            {
                                "$ref": "#/components/schemas/authn-hash.bcrypt"
                            }
                        ]
                    },
                    "enable": {
                        "default": true,
                        "description": "Set to <code>true</code> or <code>false</code> to disable this auth provider.",
                        "label": "Enable",
                        "type": "boolean"
                    },
                    "mongo_type": {
                        "default": "sharded",
                        "description": "Sharded cluster.",
                        "label": "Sharded cluster",
                        "symbols": [
                            "sharded"
                        ],
                        "type": "enum"
                    },
                    "servers": {
                        "description": "</br>A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`</br>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.</br>A host entry has the following form: `Host[:Port]`.</br>The MongoDB default port 27017 is used if `[:Port]` is not specified.</br>",
                        "items": {
                            "type": "string"
                        },
                        "label": "Servers",
                        "type": "array"
                    },
                    "w_mode": {
                        "default": "unsafe",
                        "description": "Write mode.",
                        "label": "Write Mode",
                        "symbols": [
                            "unsafe",
                            "safe"
                        ],
                        "type": "enum"
                    },
                    "srv_record": {
                        "default": false,
                        "description": "Use DNS SRV record.",
                        "label": "Srv Record",
                        "type": "boolean"
                    },
                    "pool_size": {
                        "default": 8,
                        "description": "Size of the connection pool.",
                        "label": "Pool Size",
                        "type": "string"
                    },
                    "username": {
                        "description": "EMQX's username in the external database.",
                        "label": "Username",
                        "type": "string"
                    },
                    "password": {
                        "description": "EMQX's password in the external database.",
                        "label": "Password",
                        "type": "string"
                    },
                    "auth_source": {
                        "description": "Database name associated with the user's credentials.",
                        "label": "Auth Source",
                        "type": "string"
                    },
                    "database": {
                        "description": "Database name.",
                        "label": "Database Name",
                        "type": "string"
                    },
                    "topology": {
                        "description": "topology Description",
                        "label": "topology",
                        "$ref": "#/components/schemas/emqx_connector_mongo.topology"
                    },
                    "ssl": {
                        "default": {
                            "enable": false
                        },
                        "description": "SSL connection settings.",
                        "label": "Enable SSL",
                        "$ref": "#/components/schemas/broker.ssl_client_opts"
                    }
                },
                "type": "object"
            },
            "dashboard.dashboard": {
                "required": [
                    "default_password",
                    "default_username"
                ],
                "properties": {
                    "listeners": {
                        "description": "HTTP(s) listeners are identified by their protocol type and are</br>used to serve dashboard UI and restful HTTP API.</br>Listeners must have a unique combination of port number and IP address.</br>For example, an HTTP listener can listen on all configured IP addresses</br>on a given port for a machine by specifying the IP address 0.0.0.0.</br>Alternatively, the HTTP listener can specify a unique IP address for each listener,</br>but use the same port.",
                        "label": "Listeners",
                        "$ref": "#/components/schemas/dashboard.listeners"
                    },
                    "default_username": {
                        "default": "admin",
                        "description": "The default username of the automatically created dashboard user.",
                        "label": "Default username",
                        "readOnly": true,
                        "type": "string"
                    },
                    "default_password": {
                        "default": "public",
                        "description": "The initial default password for dashboard 'admin' user.</br>For safety, it should be changed as soon as possible.",
                        "label": "Default password",
                        "readOnly": true,
                        "type": "string"
                    },
                    "sample_interval": {
                        "default": "10s",
                        "description": "How often to update metrics displayed in the dashboard.</br>Note: `sample_interval` should be a divisor of 60.",
                        "label": "sample_interval",
                        "type": "duration"
                    },
                    "token_expired_time": {
                        "default": "60m",
                        "description": "JWT token expiration time.",
                        "label": "Token expired time",
                        "type": "duration"
                    },
                    "cors": {
                        "default": false,
                        "description": "Support Cross-Origin Resource Sharing (CORS).</br>Allows a server to indicate any origins (domain, scheme, or port) other than</br>its own from which a browser should permit loading resources.",
                        "label": "CORS",
                        "type": "boolean"
                    },
                    "i18n_lang": {
                        "default": "en",
                        "description": "Internationalization language support.",
                        "label": "I18n language",
                        "readOnly": true,
                        "symbols": [
                            "en",
                            "zh"
                        ],
                        "type": "enum"
                    }
                },
                "type": "object"
            },
            "zone.force_shutdown": {
                "properties": {
                    "enable": {
                        "description": "Enable `force_shutdown` feature.",
                        "label": "Enable `force_shutdown` feature.",
                        "type": "boolean"
                    },
                    "max_message_queue_len": {
                        "description": "Maximum message queue length.",
                        "label": "Maximum mailbox queue length of process.",
                        "minimum": 0,
                        "type": "number"
                    },
                    "max_heap_size": {
                        "description": "Total heap size",
                        "label": "Total heap size",
                        "type": "byteSize"
                    }
                },
                "type": "object"
            }
        }
    },
    "info": {
        "title": "EMQX Hot Conf Schema",
        "version": "0.1.0"
    },
    "paths": {
        "/configs": {
            "get": {
                "properties": {
                    "listeners": {
                        "description": "listeners Description",
                        "label": "listeners",
                        "$ref": "#/components/schemas/broker.listeners"
                    },
                    "zones": {
                        "description": "A zone is a set of configs grouped by the zone <code>name</code>.</br>For flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.</br>NOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.</br>",
                        "label": "zones",
                        "properties": {
                            "$name": {
                                "$ref": "#/components/schemas/broker.zone"
                            }
                        },
                        "type": "object"
                    },
                    "node": {
                        "description": "node Description",
                        "label": "node",
                        "$ref": "#/components/schemas/cluster.node"
                    },
                    "cluster": {
                        "description": "cluster Description",
                        "label": "cluster",
                        "$ref": "#/components/schemas/cluster.cluster"
                    },
                    "log": {
                        "description": "log Description",
                        "label": "log",
                        "$ref": "#/components/schemas/cluster.log"
                    },
                    "broker": {
                        "description": "Message broker options.",
                        "label": "broker",
                        "$ref": "#/components/schemas/broker.broker"
                    },
                    "sysmon": {
                        "description": "sysmon Description",
                        "label": "sysmon",
                        "$ref": "#/components/schemas/broker.sysmon"
                    },
                    "alarm": {
                        "description": "alarm Description",
                        "label": "alarm",
                        "$ref": "#/components/schemas/broker.alarm"
                    },
                    "persistent_session_store": {
                        "description": "persistent_session_store Description",
                        "label": "persistent_session_store",
                        "$ref": "#/components/schemas/broker.persistent_session_store"
                    },
                    "trace": {
                        "description": "trace Description",
                        "label": "trace",
                        "$ref": "#/components/schemas/broker.trace"
                    },
                    "dashboard": {
                        "description": "Configuration for EMQX dashboard.",
                        "label": "Dashboard",
                        "$ref": "#/components/schemas/dashboard.dashboard"
                    },
                    "limiter": {
                        "description": "Settings for the rate limiter.",
                        "label": "limiter",
                        "$ref": "#/components/schemas/limiter.limiter"
                    }
                },
                "type": "object"
            }
        },
        "/configs/alarm": {
            "get": {
                "$ref": "#/components/schemas/broker.alarm"
            },
            "put": {
                "$ref": "#/components/schemas/broker.alarm"
            }
        },
        "/configs/broker": {
            "get": {
                "$ref": "#/components/schemas/broker.broker"
            },
            "put": {
                "$ref": "#/components/schemas/broker.broker"
            }
        },
        "/configs/cluster": {
            "get": {
                "$ref": "#/components/schemas/cluster.cluster"
            },
            "put": {
                "$ref": "#/components/schemas/cluster.cluster"
            }
        },
        "/configs/dashboard": {
            "get": {
                "$ref": "#/components/schemas/dashboard.dashboard"
            },
            "put": {
                "$ref": "#/components/schemas/dashboard.dashboard"
            }
        },
        "/configs/global_zone": {
            "get": {
                "properties": {
                    "mqtt": {
                        "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                        "label": "mqtt",
                        "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "stats": {
                        "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                        "label": "stats",
                        "$ref": "#/components/schemas/zone.stats"
                    },
                    "flapping_detect": {
                        "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                        "label": "flapping_detect",
                        "$ref": "#/components/schemas/zone.flapping_detect"
                    },
                    "force_shutdown": {
                        "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                        "label": "force_shutdown",
                        "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "conn_congestion": {
                        "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                        "label": "conn_congestion",
                        "$ref": "#/components/schemas/zone.conn_congestion"
                    },
                    "force_gc": {
                        "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                        "label": "force_gc",
                        "$ref": "#/components/schemas/zone.force_gc"
                    },
                    "overload_protection": {
                        "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                        "label": "overload_protection",
                        "$ref": "#/components/schemas/zone.overload_protection"
                    }
                },
                "type": "object"
            },
            "put": {
                "properties": {
                    "mqtt": {
                        "description": "Global MQTT configuration.</br>The configs here work as default values which can be overridden</br>in <code>zone</code> configs",
                        "label": "mqtt",
                        "$ref": "#/components/schemas/zone.mqtt"
                    },
                    "stats": {
                        "description": "Enable/disable statistic data collection.</br>Statistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
                        "label": "stats",
                        "$ref": "#/components/schemas/zone.stats"
                    },
                    "flapping_detect": {
                        "description": "This config controls the allowed maximum number of `CONNECT` packets received</br>from the same clientid in a time frame defined by `window_time`.</br>After the limit is reached, successive `CONNECT` requests are forbidden</br>(banned) until the end of the time period defined by `ban_time`.",
                        "label": "flapping_detect",
                        "$ref": "#/components/schemas/zone.flapping_detect"
                    },
                    "force_shutdown": {
                        "description": "When the process message queue length, or the memory bytes</br>reaches a certain value, the process is forced to close.</br></br>Note: \"message queue\" here refers to the \"message mailbox\"</br>of the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
                        "label": "force_shutdown",
                        "$ref": "#/components/schemas/zone.force_shutdown"
                    },
                    "conn_congestion": {
                        "description": "Settings for `conn_congestion` alarm.</br></br>Sometimes the MQTT connection (usually an MQTT subscriber) may</br>get \"congested\", because there are too many packets to be sent.</br>The socket tries to buffer the packets until the buffer is</br>full. If more packets arrive after that, the packets will be</br>\"pending\" in the queue, and we consider the connection</br>congested.</br></br>Note: `sndbuf` can be set to larger value if the</br>alarm is triggered too often.</br>The name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,</br>where the `<ClientID>` is the client ID of the congested MQTT connection,</br>and `<Username>` is the username or `unknown_user`.",
                        "label": "conn_congestion",
                        "$ref": "#/components/schemas/zone.conn_congestion"
                    },
                    "force_gc": {
                        "description": "Force garbage collection in MQTT connection process after</br> they process certain number of messages or bytes of data.",
                        "label": "force_gc",
                        "$ref": "#/components/schemas/zone.force_gc"
                    },
                    "overload_protection": {
                        "description": "Overload protection mechanism monitors the load of the system and temporarily</br>disables some features (such as accepting new connections) when the load is high.",
                        "label": "overload_protection",
                        "$ref": "#/components/schemas/zone.overload_protection"
                    }
                },
                "type": "object"
            }
        },
        "/configs/limiter": {
            "get": {
                "$ref": "#/components/schemas/limiter.limiter"
            },
            "put": {
                "$ref": "#/components/schemas/limiter.limiter"
            }
        },
        "/configs/limiter/:limiter_type": {
            "get": {
                "$ref": "#/components/schemas/limiter.limiter_opts"
            },
            "put": {
                "$ref": "#/components/schemas/limiter.limiter_opts"
            }
        },
        "/configs/listeners": {
            "get": {
                "$ref": "#/components/schemas/broker.listeners"
            },
            "put": {
                "$ref": "#/components/schemas/broker.listeners"
            }
        },
        "/configs/log": {
            "get": {
                "$ref": "#/components/schemas/cluster.log"
            },
            "put": {
                "$ref": "#/components/schemas/cluster.log"
            }
        },
        "/configs/node": {
            "get": {
                "$ref": "#/components/schemas/cluster.node"
            },
            "put": {
                "$ref": "#/components/schemas/cluster.node"
            }
        },
        "/configs/persistent_session_store": {
            "get": {
                "$ref": "#/components/schemas/broker.persistent_session_store"
            },
            "put": {
                "$ref": "#/components/schemas/broker.persistent_session_store"
            }
        },
        "/configs/sysmon": {
            "get": {
                "$ref": "#/components/schemas/broker.sysmon"
            },
            "put": {
                "$ref": "#/components/schemas/broker.sysmon"
            }
        },
        "/configs/trace": {
            "get": {
                "$ref": "#/components/schemas/broker.trace"
            },
            "put": {
                "$ref": "#/components/schemas/broker.trace"
            }
        },
        "/configs/zones": {
            "get": {
                "properties": {
                    "$name": {
                        "$ref": "#/components/schemas/broker.zone"
                    }
                },
                "type": "object"
            },
            "put": {
                "properties": {
                    "$name": {
                        "$ref": "#/components/schemas/broker.zone"
                    }
                },
                "type": "object"
            }
        },
        "/configs_reset/:rootname": {}
    }
}